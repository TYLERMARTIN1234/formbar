{% extends 'header_fullscreen.html' %}
<!-- ^^ This means add this file into the contents of the header page -->
<!-- This is where the title, top buttons, and stylesheet is located -->

<!-- Change title here -->
{% block title %}Blewnz{% endblock %}

<!-- Extra style declarations here -->
{% block style %}
<style>
  body {
    background: var(--bg-darker);
    user-select: none;
  }

  #container {
    aspect-ratio: 16 / 9;
    outline: 1px solid var(--dark-gray);
    overflow: hidden;
    text-align: left;
  }

  @media (max-aspect-ratio: 16/9) { /*If the window is taller than 16/9*/
    #container {
      width: 100%;
      font-size: calc(5vw / 6);
    }

    :root {
      --game-width: 100vw;
      --game-height: calc(900vw / 16);
    }
  }

  @media (min-aspect-ratio: 16/9) { /*If the window is wider than 16/9*/
    #container {
      height: 100%;
      font-size: calc(40vh / 27);
    }

    :root {
      --game-width: calc(1600vh / 9);
      --game-height: 100vh;
    }
  }

  #game {
    position: absolute;
    width: 100%;
    background: linear-gradient(to bottom right, #040, #400, #004);
    background-size: 100%;
  }

  button:not(.inline) {
    background: transparent;
    border-width: 2px;
  }

  button:not(.inline):not(.unselectable):hover {
    background: #fff2;
  }

  #progress {
    position: absolute;
    left: 1.5%;
    top: calc(24% / 9);
    width: 100%;
    color: var(--light-blue);
  }

  #progressText {
    font-size: 250%;
  }

  #achievements {
    margin-top: 1%;
    font-size: 200%;
  }

  #achvButton {
    margin-left: 0.75%;
    font-size: 75%;
    color: inherit;
  }

  .complete {
    color: var(--light-yellow) !important;
  }

  .complete span,
  .complete button:not(:hover) {
    filter: drop-shadow(0 0 5px #fffa);
  }

  #playButton, #tryAgain {
    top: 50%;
    width: 15%;
    font-size: 300%;
    color: white;
  }

  #editorButton, #home {
    top: 60%;
    width: 12%;
    font-size: 200%;
    color: white;
  }

  #back {
    position: absolute;
    left: 0;
    top: 0;
    width: calc(75% / 16);
    height: calc(75% / 9);
    padding: 0;
    text-align: center;
    font-size: 400%;
    line-height: 130%;
    color: white;
    cursor: pointer;
  }

  #removeButton {
    position: absolute;
    right: 0;
    top: 0;
    width: calc(75% / 16);
    height: calc(75% / 9);
    padding: 0;
    cursor: pointer;
  }

  #removeBox {
    position: absolute;
    width: 40%;
    height: 50%;
    padding: 1.5%;
    box-sizing: border-box;
    background: #cccc;
    color: var(--bg-darker);
    font-size: 175%;
    text-align: left;
    filter: drop-shadow(10px 10px 5px #000c);
  }

  #removeBox h2 {
    margin-top: 0;
    text-align: center;
  }

  #digipogs {
    width: 12%;
  }

  #removeBox button {
    position: absolute;
    bottom: 6%;
    width: 25%;
    height: 12%;
    padding: 0.25% 1%;
    background: white !important;
    font-size: calc(400% / 3);
    filter: drop-shadow(2px 2px 1px #000c);
  }

  #removeBox #cancel {
    left: 22.5%;
    color: var(--color-red);
  }

  #removeBox #send {
    right: 22.5%;
    color: var(--color-blue);
  }

  #removeBox button:not(.unselectable):hover {
    filter: brightness(90%) drop-shadow(2px 2px 1px #000c);
  }

  #prevMap {
    position: absolute;
    left: 15%;
    top: calc(250% / 9);
    width: calc(75% / 16);
    height: calc(75% / 9);
    padding: 0;
    text-align: center;
    font-size: 400%;
    line-height: 130%;
    color: var(--light-cyan);
    cursor: pointer;
  }

  #nextMap {
    position: absolute;
    right: 15%;
    top: calc(250% / 9);
    width: calc(75% / 16);
    height: calc(75% / 9);
    padding: 0;
    text-align: center;
    font-size: 400%;
    line-height: 130%;
    color: var(--light-cyan);
    cursor: pointer;
  }

  #prevMap:active,
  #nextMap:active {
    color: white;
  }

  #difficulty {
    position: absolute;
    left: 0;
    top: 56%;
    width: 100%;
    text-align: center;
    font-size: 200%;
  }

  #normal,
  #hard {
    padding: 0.25% 1%;
    margin: 0 0.5%;
    font-size: calc(inherit x 0.75);
    font-weight: 500;
  }

  #normal {
    color: var(--light-green);
  }

  #normal.pressed {
    background: var(--light-green);
    border-color: var(--light-green);
    color: var(--bg-dark);
  }

  #hard {
    color: var(--light-orange);
  }

  #hard.pressed {
    background: var(--light-orange);
    border-color: var(--light-orange);
    color: var(--bg-dark);
  }

  #startButton {
    position: absolute;
    bottom: 5%;
    padding: 0.25% 1%;
    color: var(--light-cyan);
    font-size: 200%;
    font-weight: 500;
  }

  #grid {
    position: absolute;
    top: 0;
    width: 100%;
    aspect-ratio: 32 / 15;
    border-collapse: collapse;
  }

  table,
  td {
    border: none;
  }

  td {
    width: calc(100% / 32);
  }

  .visibleLines td {
    border: 1px solid #555;
  }

  td.gameButton {
    cursor: pointer;
  }

  td.droppable {
    background: #aaa5;
  }

  td.undroppable {
    background: #a555;
  }
  
  #grid:not(.paused) td.tower {
    cursor: pointer;
  }

  #controls {
    position: absolute;
    top: calc(100% / 72);
    left: calc(100% / 128);
    width: 20%;
    box-sizing: border-box;
    color: var(--bg-dark);
    text-align: left;
    filter: drop-shadow(10px 10px 5px #000c);
  }

  #controls div {
    height: 10%;
    padding: 5%;
    font-size: 175%;
    font-weight: 600;
    background: #cccc;
    cursor: pointer;
  }

  #controls div.unselectable {
    opacity: 100%;
    cursor: not-allowed;
    color: #555;
  }

  #controls div:not(.unselectable):hover {
    background: #aaac;
  }

  #controls img {
    position: relative;
    width: 10%;
    height: 10%;
    margin-right: 5%;
    vertical-align: middle;
    bottom: calc(var(--game-height) / 500);
  }

  #alert {
    position: absolute;
    width: 30%;
    height: 30%;
    padding: 1.5%;
    box-sizing: border-box;
    background: #cccc;
    color: var(--bg-dark);
    font-size: 150%;
    text-align: left;
    border: 1px solid var(--dark-gray);
    filter: drop-shadow(10px 10px 5px #000c);
  }

  #alert.large {
    height: 50%;
  }

  #alert.error b {
    color: var(--color-red);
  }

  #alertText {
    position: absolute;
    top: calc(5% * 16 / 9);
    left: 5%;
    width: 90%;
    height: 50%;
    overflow: auto;
  }

  #alertText *:not(#alertInput) {
    position: static !important;
    pointer-events: none !important;
  }

  #alert.large #alertText {
    top: calc(5% * 16 / 15);
    height: 70%;
  }

  #alert h1 {
    margin: 0 0 3% 0;
    font-size: 125%;
    font-weight: normal;
  }

  #alertInput {
    position: absolute;
    bottom: 0;
    width: calc(100% - 60px);
    text-align: left;
  }

  li.earned::marker {
    content: "🗸  ";
  }
  
  #alert button {
    position: absolute;
    bottom: 10%;
    width: 20%;
    height: 20%;
    padding: 0.25% 1%;
    background: white !important;
    font-size: calc(400% / 3);
    font-weight: 500;
    filter: drop-shadow(2px 2px 1px #000c);
  }

  #ok {
    color: var(--color-blue);
    left: 40%;
  }

  #yes {
    color: var(--color-green);
    left: 25%;
  }

  #no {
    color: var(--color-red);
    right: 25%;
  }

  #alert.large button {
    height: 12%;
    bottom: 6%;
  }

  #alert button:not(.unselectable):hover {
    filter: brightness(90%) drop-shadow(2px 2px 1px #000c);
  }

  .menu {
    position: absolute;
    min-width: 15%;
    max-width: 20%;
    padding: 0.5%;
    box-sizing: border-box;
    background: #cccc;
    color: var(--bg-dark);
    text-align: center;
    filter: drop-shadow(10px 10px 5px #000c);
  }

  .splitButton {
    color: var(--color-green);
    border: 1px solid;
    border-radius: 4px;
    font-size: 80%;
    font-weight: 500;
    filter: drop-shadow(2px 2px 1px #000c);
  }

  .splitButton:not(.unselectable) {
    cursor: pointer;
  }

  .buttonLeft {
    width: fit-content;
    padding: 0 1.5%;
    border-radius: 4px 0 0 4px;
    background: white;
  }

  .buttonRight {
    width: fit-content;
    padding: 0 1.5%;
    border-radius: 0 4px 4px 0;
    background: var(--color-green);
    color: white;
  }

  .splitButton:not(.unselectable):hover {
    filter: brightness(90%) drop-shadow(2px 2px 1px #000c);
  }

  .sellButton {
    color: var(--color-red);
  }

  .sellButton .buttonRight {
    background: var(--color-red);
  }

  .bought .buttonLeft {
    border-radius: 4px;
  }

  .bought .buttonRight {
    display: none;
  }

  .menu h1 {
    margin: 0 0 4% 0;
    font-size: 150%;
    font-weight: normal;
  }

  .menu h2 {
    margin: 3% 0 0 0;
    font-size: 125%;
    font-weight: normal;
  }

  #towers {
    position: absolute;
    bottom: 0;
    width: 100%;
    aspect-ratio: 32 / 3;
    display: flex;
    justify-content: center;
    align-items: center;
    gap: 5%;
    background: #0005;
    border-top: 1.5px solid var(--light-gray);
    cursor: default;
  }

  #towers img {
    height: calc(100% / 3);
  }

  #towers img:not(.unselectable):hover {
    cursor: grab;
    filter: drop-shadow(0 0 6px white);
  }

  #towers img:not(.unselectable):active {
    cursor: grabbing;
  }

  #towers img.unselectable {
    opacity: 25%;
  }

  #towerDesc {
    position: absolute;
    top: 5%;
    width: 100%;
    text-align: center;
    font-size: 150%;
  }

  #powers {
    position: absolute;
    bottom: 10%;
    width: 100%;
    display: flex;
    justify-content: center;
    align-items: center;
    gap: 3%;
    text-align: center;
  }

  #powers button {
    width: 5.125%;
    padding: 0.1% 0.3%;
    font-size: 100%;
  }

  .invisible {
    visibility: hidden;
  }

  .powerReady {
    animation: powerReady 1s;
  }

  @keyframes powerReady {
    12.5% {
      transform: rotate(1deg);
    }

    37.5% {
      transform: rotate(-2deg);
    }

    50% {
      background: #fff2;
      color: white;
    }

    62.5% {
      transform: rotate(2deg);
    }

    87.5% {
      transform: rotate(-1deg);
    }
  }

  #myMaps {
    width: 70%;
    height: 80%;
    bottom: 0;
    padding: 3% 3% 0;
    display: grid;
    grid-template-columns: repeat(3, 30%);
    grid-template-rows: 40%;
    gap: 5%;
    font-size: 200%;
    text-align: left;
    overflow: auto;
  }

  .mapWrapper {
    position: relative;
    overflow: hidden;
    white-space: nowrap;
    cursor: pointer;
  }

  #newMap {
    width: 100%;
    aspect-ratio: 16 / 9;
    box-sizing: border-box;
    margin-bottom: 2%;
    border: 1px solid white;
    font-size: 567%;
    line-height: 100%;
    text-align: center;
  }

  .mapWrapper:hover #newMap,
  .mapWrapper:hover .mapThumbnail {
    background: #fff3;
  }

  .mapThumbnail {
    width: 100%;
    aspect-ratio: 16 / 9;
    box-sizing: border-box;
    border: 1px solid white;
    cursor: pointer;
  }

  .lastEdited {
    font-size: 75%;
    color: var(--light-gray);
  }

  .mapStatus {
    position: absolute;
    left: 1px;
    top: 1px;
    width: fit-content;
    padding: 1% 1.5%;
    border: 1px;
    border-style: none solid solid none;
    border-bottom-right-radius: 6px;
    font-size: 60%;
    text-transform: uppercase;
  }

  .uncleared {
    background-color: #850a;
    color: var(--light-yellow);
  }

  .ready {
    background-color: #050a;
    color: var(--light-green);
  }

  .published {
    background-color: #118a;
    color: var(--light-blue);
  }

  .removed {
    background-color: #820a;
    color: var(--light-orange);
  }

  #mapInfo {
    position: absolute;
    width: 40%;
    height: 50%;
    padding: 1.5%;
    box-sizing: border-box;
    background: #cccc;
    color: var(--bg-darker);
    font-weight: 600;
    font-size: 200%;
    text-align: left;
    filter: drop-shadow(10px 10px 5px #000c);
  }

  #mapInfo.edit {
    height: 60%;
  }

  #mapInfo.removed {
    padding: 1.5% 5%;
    text-align: center;
  }

  #mapInfo h2 {
    margin-top: 0;
    text-align: center;
  }

  #digipogs {
    width: 12%;
  }

  #mapInfo button {
    position: absolute;
    bottom: 6%;
    width: 25%;
    height: 12%;
    padding: 0.25% 1%;
    background: white !important;
    font-size: calc(400% / 3);
    filter: drop-shadow(2px 2px 1px #000c);
  }

  #mapInfo #cancel {
    left: 22.5%;
    color: var(--color-red);
  }

  #mapInfo #next {
    right: 22.5%;
    color: var(--color-blue);
  }

  #mapInfo.edit button {
    height: 10%;
  }

  #mapInfo.edit #test {
    left: 7.5%;
    bottom: 20%;
    color: var(--color-green);
  }

  #mapInfo.edit #publish {
    left: 37.5%;
    bottom: 20%;
    color: var(--color-purple);
  }

  #mapInfo.edit #delete {
    right: 7.5%;
    bottom: 20%;
    color: var(--color-orange);
  }

  #mapInfo.edit #cancel {
    left: 7.5%;
  }

  #mapInfo.edit #save {
    left: 37.5%;
    color: var(--color-gold);
  }

  #mapInfo.edit #edit {
    right: 7.5%;
    color: var(--color-blue);
  }

  #unpublishToEdit {
    margin-top: 10%;
    text-align: center;
    font-size: 90%;
    font-weight: normal;
  }

  #mapInfo.removed #cancel {
    left: 10%;
  }

  #mapInfo.removed #delete {
    left: 40%;
    width: 50%;
    font-size: 110%;
    color: var(--color-orange);
  }

  #mapInfo button:not(.unselectable):hover {
    filter: brightness(90%) drop-shadow(2px 2px 1px #000c);
  }

  #lightBackground {
    width: 100%;
    height: 100%;
    background: var(--light-gray);
    color: var(--bg-dark);
  }

  #lightBackground #back {
    color: inherit;
  }

  #editorHeader {
    position: absolute;
    top: 2%;
    margin: 0;
    font-size: 350%;
  }

  #visual,
  #text {
    position: absolute;
    top: 12%;
    width: 5.5%;
    padding: 0.25% 1%;
    margin: 0 0.5%;
    text-align: center;
    font-size: calc(150%);
    font-weight: 500;
    background: white;
    color: var(--color-blue);
    filter: drop-shadow(2px 2px 1px #000c);
  }

  #visual:hover,
  #text:hover {
    background: #ddd;
  }

  #visual.pressed,
  #text.pressed {
    background: var(--color-blue);
    border-color: var(--color-blue);
    color: white;
  }

  #visual {
    left: 43.5%;
  }

  #text {
    right: 43.5%;
  }

  #newMapCanvas {
    position: absolute;
    left: 5%;
    bottom: 10%;
    height: 72%;
    aspect-ratio: 17 / 10;
    background: linear-gradient(to bottom right, #040, #400, #004);
    filter: drop-shadow(6px 6px 3px #000c);
  }

  #newMapGrid {
    position: absolute;
    left: 5%;
    bottom: 10%;
    height: 72%;
    aspect-ratio: 17 / 10;
    border-collapse: collapse;
    cursor: crosshair;
  }

  #newMapGrid td {
    width: calc(100% / 34);
    height: 5%;
    border-color: gray;
  }

  #newMapGrid td:nth-child(17) {
    border-right-color: white;
  }

  #newMapGrid td:nth-child(18) {
    border-left-color: white;
  }

  #newMapGrid td:nth-child(1) {
    border-left: none;
    background: #ccc5;
  }

  #newMapGrid td:nth-child(34) {
    border-right: none;
    background: #ccc5;
  }

  #newMapGrid tr:nth-child(1) td {
    border-top: none;
    background: #ccc5;
  }

  #newMapGrid tr:nth-child(20) td {
    border-bottom: none;
    background: #ccc5;
  }

  td.line {
    cursor: grab;
  }

  #newMapGrid.draggingLine td {
    cursor: grabbing;
  }

  td.corner {
    cursor: move;
  }

  #editorTowers {
    position: absolute;
    left: 7.025%;
    bottom: 13.6%;
    height: 10.8%;
    aspect-ratio: 32 / 3;
    background: #0005;
    border-top: 1.5px solid var(--light-gray);
    pointer-events: none;
  }

  #pathInstructions {
    position: absolute;
    left: 76%;
    top: 22%;
    width: 20%;
    font-size: 150%;
    text-align: left;
  }

  #pathInstructions * {
    margin-top: 0;
    margin-bottom: 5%;
  }

  #pathInstructions ul {
    padding-left: 7.5%;
  }

  #textEditor {
    position: absolute;
    bottom: 10%;
    width: 40%;
    height: 72%;
    box-sizing: border-box;
    padding: 2%;
    font-size: 175%;
    text-align: left;
    color: var(--bg-dark);
    font-weight: 500;
  }

  #pathText {
    width: 100%;
    height: 80%;
    box-sizing: border-box;
    margin-top: 1%;
    padding: 1%;
    color: var(--bg-dark);
  }

  #alertCover {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
  }

  #lightBackground button {
    position: absolute;
    bottom: 2%;
    width: 8%;
    height: 6%;
    padding: 0.1% 0.4%;
    background: white !important;
    font-size: calc(800% / 3);
    filter: drop-shadow(2px 2px 1px #000c);
    color: var(--color-blue);
    left: 46%;
  }

  #lightBackground button:hover {
    filter: brightness(90%) drop-shadow(2px 2px 1px #000c);
  }

  #wavesBox {
    position: absolute;
    left: 8%;
    bottom: 10%;
    height: 72%;
    aspect-ratio: 3 / 2;
    padding: 0.5%;
    box-sizing: border-box;
    background: var(--bg-darker);
    filter: drop-shadow(6px 6px 3px #000c);
    overflow: auto;
  }

  #wavesBox.movingWave {
    cursor: move;
  }

  .wave {
    position: relative;
    min-width: 96%;
    width: fit-content;
    height: calc(var(--game-height) / 10 + 4px);
    box-sizing: border-box;
    display: flex;
    align-items: center;
    gap: calc(var(--game-width) / 100);
    padding-right:  calc(var(--game-width) / 50);
    margin: 2%;
    background: var(--bg-dark-highlight);
    border: 2px solid gray;
    border-radius: 9999px;
    filter: drop-shadow(6px 6px 3px #000c);
  }

  .wave:nth-child(n + 51) {
    background: #522;
  }

  #hardModeOnly {
    width: 100%;
    margin: auto;
    text-align: center;
    color: var(--light-red);
  }

  #hardModeOnly:before, #hardModeOnly:after {
    content: "";
    display: inline-block;
    width: 30%;
    margin: 0 2%;
    vertical-align: middle;
    border: 1px solid;
  }

  #removeItem {
    position: absolute;
    top: 0;
    width: 20%;
    height: 7.5%;
    border-radius: 0 0 8px 8px;
    background: #bf0000cc;
    color: white;
    font-size: 225%;
    text-align: center;
    filter: drop-shadow(6px 6px 3px #000c);
  }

  #removeItem.dragOver {
    background: var(--color-red);
    filter: drop-shadow(0 0 6px white);
  }

  .waveNumber {
    height: 100%;
    aspect-ratio: 1;
    box-sizing: border-box;
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: 300%;
    color: var(--light-gray);
    border: 2px gray;
    border-right-style: solid;
    border-radius: 9999px 0 0 9999px;
    cursor: move;
  }

  .waveEnemy {
    position: relative;
    height: 50%;
    display: flex;
    justify-content: center;
    align-items: center;
    flex-shrink: 0;
    border-radius: 100%;
    overflow: hidden;
    filter: drop-shadow(4px 4px 2px #000c);
  }

  #enemyOutline, #repeatEnemyOutline, #innerRepeatEnemyOutline {
    box-sizing: border-box;
    background: #0003 !important;
    border: 2px dashed var(--light-gray) !important;
    pointer-events: none;
    filter: drop-shadow(0 0 0 #000);
  }

  .waveEnemy:not(.waveRepeat) {
    aspect-ratio: 1;
  }

  .waveEnemy.boss {
    aspect-ratio: 2;
  }

  .waveEnemy img {
    height: 200%;
  }

  .abilitySymbol {
    position: absolute;
    pointer-events: none;
  }

  .blink {
    animation: 2s steps(2, jump-none) 0s blink infinite;
  }

  @keyframes blink {
    0% {
      opacity: 100%;
    }

    100% {
      opacity: 50%;
    }
  }

  .waveRepeat, #repeat {
    height: calc(var(--game-height) * 0.075);
    min-width: calc(var(--game-height) * 0.120625 + var(--game-width) * 0.00825);
    padding-right: calc(var(--game-width) * 0.00825 + calc(var(--game-height) * 0.020625));
    display: flex;
    justify-content: flex-start;
    gap: calc(var(--game-width) * 0.00825);
    background: #455;
    border: 2px solid var(--light-cyan);
    border-radius: 16px;
  }

  .repeatNumber {
    height: 100%;
    aspect-ratio: 4 / 3;
    box-sizing: border-box;
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: 200%;
    color: white;
    border: 2px var(--light-cyan);
    border-right-style: solid;
  }

  .repeatNumber input {
    width: 50%;
    text-align: right;
  }

  .repeatNumber input::-webkit-outer-spin-button,
  .repeatNumber input::-webkit-inner-spin-button {
    -webkit-appearance: none;
    margin: 0;
  }

  .waveRepeat .waveEnemy {
    height: 55%;
  }

  .waveRepeat .waveRepeat {
    height: 75%;
    min-width: calc(var(--game-height) * 0.09328125 + var(--game-width) * 0.0073125);
    padding-right: calc(var(--game-width) * 0.0073125 + calc(var(--game-height) * 0.01828125));
    gap: calc(var(--game-width) * 0.0073125);
    background: #545;
    border-color: var(--light-purple);
    border-radius: 12px;
  }

  .waveRepeat .waveRepeat .repeatNumber {
    font-size: 150%;
    border-color: var(--light-purple);
  }

  .waveRepeat .waveRepeat .waveEnemy {
    height: 65%;
  }

  #enemiesBox {
    position: absolute;
    left: 72%;
    bottom: 10%;
    height: 72%;
    aspect-ratio: 1 / 2;
    box-sizing: border-box;
    display: flex;
    flex-wrap: wrap;
    align-content: flex-start;
    justify-content: center;
    text-align: center;
    background: var(--bg-darker);
    color: white;
    filter: drop-shadow(6px 6px 3px #000c);
  }

  #enemiesBox h1 {
    margin-bottom: 0;
  }

  #ability {
    margin: 3.75% 10%;
    font-size: 150%;
  }

  #abilityDropdown {
    width: 65%;
    filter: drop-shadow(4px 4px 2px #000c);
  }

  #enemiesBox button {
    width: 25%;
    font-size: 125%;
    padding: 0.5% 1%;
    margin: 1.5%;
    border-radius: 8px;
  }

  .enemy {
    position: relative;
    height: calc(var(--game-height) / 20);
    margin: 3.75% 7.5%;
    aspect-ratio: 1;
    display: flex;
    justify-content: center;
    align-items: center;
    border-radius: 100%;
    overflow: hidden;
    filter: drop-shadow(4px 4px 2px #000c);
  }

  .enemy.boss {
    height: calc(var(--game-height) / 10);
    aspect-ratio: 1 / 2;
  }

  .enemy img {
    height: 200%;
  }

  .enemy.boss img {
    height: 100%;
  }

  .enemy:not(.unselectable):hover, .waveEnemy:not(:has(.waveEnemy:hover)):not(:has(.repeatNumber input:hover)):hover {
    cursor: grab;
    filter: drop-shadow(0 0 6px white);
  }

  .enemy:not(.unselectable):active, .waveEnemy:active {
    cursor: grabbing !important;
  }

  .dragTarget {
    filter: drop-shadow(0 0 6px white);
  }

  .wave.dragTarget *:not(.waveRepeat), .waveRepeat.dragTarget *:not(.waveRepeat) {
    pointer-events: none;
  }

  #contextMenu {
    position: absolute;
    width: 15%;
    padding: 0.25% 0;
    border: 1px solid gray;
    font-size: 150%;
    background: var(--bg-dark);
    color: white;
    filter: drop-shadow(6px 6px 3px #000c);
  }

  #contextMenu * {
    padding: 2% 5%;
  }

  #contextMenu b {
    display: block;
    text-align: center;
  }

  #contextMenu div:not(.unselectable) {
    cursor: pointer;
  }

  #contextMenu div:not(.unselectable):hover {
    background-color: var(--light-green);
    color: var(--bg-dark);
  }

  #wavesInstructions {
    position: absolute;
    left: 13%;
    width: 27%;
    font-size: 125%;
  }

  #wavesInstructions > * {
    margin-top: 0;
    margin-bottom: 3%;
  }

  #enemyCodes {
    column-count: 2;
    text-align: left;
  }

  #enemyCodes ul {
    margin: 0;
    break-after: column;
  }

  .mono {
    font-family: monospace;
  }

  #wavesInstructions h4 {
    font-size: 110%;
  }

  #wavesText {
    position: absolute;
    left: 45%;
    bottom: 10%;
    width: 40%;
    height: 72%;
    box-sizing: border-box;
    padding: 1%;
    font-size: 175%;
    text-align: left;
    color: var(--bg-dark);
    font-weight: 500;
  }

  #lightBackground button#exit {
    left: 30%;
    width: 16%;
    color: var(--color-red);
  }

  #lightBackground button#test {
    left: 48%;
    width: 12%;
    color: var(--color-green);
  }
</style>
{% endblock %}

<!-- Change theme color here -->
{% block color %}green{% endblock %}

<!-- Main content here -->
{% block main %}
<div id="container" class="centered">
  <canvas id="game" width="1920" height="1080"></canvas>
  <div id="progress"></div>
  <table id="grid" class="hidden"></table>
  <div id="towers" class="hidden">
    <div id="towerDesc"></div>
    <div id="powers"></div>
  </div>
</div>
{% endblock %}

<!-- Extra javascript here -->
{% block script %}
<script>
  // When the page needs to refresh, send a signal to chat which will then refresh everyone's page
  chatSocket.on("reload", message => {
    location.reload();
  });

  let pause = [10, null];

  let wavesDefault = [
    [[4, "g", pause], "g"],
    [[7, "g", "g", pause], ["alert", "All enemy types have different health and speed stats."], "y", pause, "y"],
    [[5, "g"], [3, "y"]],
    [[20, "g"]],
    [[2, "y"], [5, [3, "g"], pause], [3, "y"]],
    [[10, "y"], [4, "o", pause], "o"],
    [[6, "g", "y", "o", pause], "g", "y", "o"],
    [[9, "y"], [7, "o"]],
    [[50, "g"]],
    [["alert", "<h1>New enemy ability: <b>Healing</b></h1>Enemies with this ability gradually regain health, so you need to destroy them quickly. They're also immune to poison."], [9, "oh", pause], "oh"],
    [[7, [6, "y", pause]], [6, "y"]],
    [[20, "oh"]],
    [[15, "o", "y"]],
    [[32, "g"], pause, [16, "y"], pause, [8, "o"], pause, [4, "r"]],
    [[6, "r"], ["alert", "<h1>New enemy ability: <b>Acceleration</b></h1>Enemies with this ability move faster as they lose health. They also can't be slowed by Slowing Towers."], [10, "oa"]],
    [[5, "g", [3, "r"], "g", pause], "g", [3, "r"], "g"],
    [[8, "oa", "ra", pause], "oa", "ra"],
    [[2, [12, "r"], pause], [12, "r"]],
    [[100, "y"]],
    [[2, "b", pause], "b"],
    [["alert", "<h1>New enemy ability: <b>Split</b></h1>Enemies with this ability split into two or more weaker enemies when they run out of health, making them much harder to destroy."], "rs"],
    [[7, "y", "o", "r", pause], [12, "rh"]],
    [[4, "os"], pause, [25, "o"], "bs"],
    [[5, "p"]],
    [[3, "pa", "bh", pause], [8, "rs", pause], "rs"],
    [["alert", "<h1>New enemy ability: <b>Blink</b></h1>Enemies with this ability switch between two states: visible and hidden. Without upgrades, towers can only hit them while they're visible."], [29, "yk", pause], "yk"],
    [[250, "g"]],
    [["alert", "Boss enemies have 100 HP."], "x"],
    ["pk"],
    [[5, "bs"]],
    [[2, [35, "r"], [5, "p"]]],
    [[14, "ba"], [26, "rh"]],
    [["alert", "<h1>New enemy ability: <b>Shield</b></h1>Enemies with this ability can only be damaged by explosions, poison, and hits from Long-Range Towers."], "gd"],
    [[30, "o"], pause, "x", pause, "x"],
    [[3, "bs"], [3, "ps"]],
    [[20, "rk"], pause, [5, "bk"]],
    [[3, "bd", pause], "bd"],
    ["xs"],
    [[10, "ok"], [8, "rh"], [19, "p"], [4, "rs"]],
    [[125, "yh"], "xa", [33, "b"]],
    [[4, "x"], [45, "r"], "xk"],
    [[7, "os"], pause, [13, "pk"], [64, "g"]],
    ["x", [18, "rd"], pause, "x"],
    [[85, "b", "p"]],
    [["alert", "Brown-boss enemies have 500 HP."], "z"],
    [[10, "x"], pause, [30, "bh"], [20, "r"]],
    [[3, "z", pause], [17, "ps"], [43, "ok"], [5, "x"]],
    [[15, "pk"], "xs", [3, "x", "z"], [300, "o"], "pd"],
    [[50, "ra"], [125, "bk"], pause, [67, "bh"], [999, "yk"], "z"],
    [[10, "g"], pause, [20, "y"], pause, [30, "o"], pause, [40, "r"], pause, [100, "p"], pause, [100, "b"], pause, [15, "x"], pause, [5, "z"]],

    //Hard mode only
    [[150, "bs"], [15, "bd"]],
    [[7, "x"], [80, "oa", "p"]],
    [[10, "za"]],
    [[100, "bk"], [12, "xh"], [75, "r", "pa", "os"]],
    [["alert", "Purple-boss enemies move much faster than normal bosses."], [4, "u", pause], "u"],
    [[30, "bd"], [3, "x"], pause, "xs"],
    [[150, "ra", "rh"]],
    [[3, "za"], pause, [2, "zh"], pause, "zk"],
    [[200, "ra"], "xd"],
    [[375, "p", "r", "b"], [20, "xa"]],
    [[6, "uh"], [15, "xa"]],
    [[50, "x"], pause, [10, "zh"]],
    [[8, "zk", pause], [20, "x"]],
    [[135, "bh", "rs"]],
    [[11, [17, "ra"], "z"]],
    [[14, "xa"], [15, [5, "od"], pause], [5, "z"], [5, "u"]],
    [[50, [2, "pa"], [5, "r"]], pause, [15, "za"]],
    [[5, "xd"]],
    [[60, "b"], [10, "uk"], [130, "b"]],
    ["uh", [10, [23, "rk"], "z"], [65, "ba"]],
    [[20, "u"], pause, [40, "xh"]],
    [[20, "pa"], [25, "pa", "xs"], pause, [200, "gd"], [3, "ua", "zh"]],
    [[111, "bh"], [8, "za"], [35, [9, "ph", "uk"]]],
    [[90, "b", "p"], pause, [100, "x"]],
    [[2, "zd", "ud", pause], "zd", "ud", [300, "ba"], [30, "xh"], pause, [20, "u", "uh", "ua"]]
  ];
</script>
<script src="{{ url_for('static', filename='js/tdMaps.js') }}"></script>
<script>
  {
    let allMaps = JSON.parse(JSON.stringify(tdMaps)); //Copy the maps array so it can't be edited from the console
    maps = allMaps.filter(mapObj => !mapObj.status || mapObj.status == "published"); //Remove unfinished maps from the editor

    let towerTypes = {
      basic: {
        name: "Basic Tower",
        color: "#ccc",
        description: "A cheap tower with average stats.",
        range: 2.5,
        speed: 1,
        strength: 1,
        price: 30,
        extra1: {
          description: "Projectiles can bounce to up to three nearby enemies.",
          price: 60,
          add: function () {
            this.bounce = 3;
          }
        },
        extra2: {
          description: "Projectiles can hit up to eight enemies.",
          price: 120,
          add: function () {
            this.bounce = 8;
          }
        },
        power: {
          description: "All Basic Towers attack 5× as fast for 10 seconds.",
          price: 75,
          use: function () {
            towers.filter(tower => tower?.name == "Basic Tower").forEach(tower => tower.speedBoost = 250);
            sound.playSFX("powerUp2");
          }
        }
      },
      slowing: {
        name: "Slowing Tower",
        color: "#80ffff",
        description: "Weaker attacks, but hits slow down enemies for 10 seconds.",
        range: 1.64,
        speed: 1.92,
        strength: 0.5,
        slowing: true,
        price: 25,
        extra1: {
          description: "Enemies lose all abilities while they are slowed down.",
          price: 45,
          add: function () {
            this.abilityBlocking = true;
          }
        },
        extra2: {
          description: "Slowing affects enemies permanently.",
          price: 135,
          add: function () {
            this.permSlow = true;
          }
        },
        power: {
          description: "Stuns every onscreen enemy for 3 seconds. Stunned enemies take twice as much damage.",
          price: 60,
          use: function () {
            enemies.forEach(enemy => enemy.stunned = 75);
            sound.playSFX("powerUp2");
          }
        }
      },
      poison: {
        name: "Poison Tower",
        color: "#df80ff",
        description: "Enemies are poisoned when hit, taking 0.6 damage a second for 5 seconds.",
        range: 3.19,
        speed: 1.2,
        strength: 0.75,
        poison: true,
        price: 55,
        extra1: {
          description: "Poison can splash to a nearby enemy.",
          price: 30,
          add: function () {
            this.poisonSplash = true;
          }
        },
        extra2: {
          description: "Poisoned enemies take damage twice a second.",
          price: 40,
          add: function () {
            this.doublePoison = true;
          }
        },
        power: {
          description: "All onscreen enemies move backward for 3 seconds.",
          price: 55,
          use: function () {
            enemies.forEach(enemy => enemy.reverse = 75);
            sound.playSFX("powerUp2");
          }
        }
      },
      longRange: {
        name: "Long-Range Tower",
        color: "#ffdf40",
        description: "Infinite range and strong attacks, but fires slowly. Targets the strongest enemy onscreen.",
        range: Infinity,
        speed: 0.34,
        strength: 6,
        price: 80,
        extra1: {
          description: "Can hit blinking enemies while they are hidden.",
          price: 15,
          add: function () {
            this.seeInvisible = true;
          }
        },
        extra2: {
          description: "Enemies hit by this tower lose all abilities permanently.",
          price: 200,
          add: function () {
            this.removeAbilities = true;
          }
        },
        power: {
          description: "Does 150 damage to the strongest enemy on the screen.",
          price: 150,
          use: function () {
            let strongest = enemies.sort((a, b) => b.health - a.health)[0];
            strongest?.hit(Infinity, this);
            sound.playSFX("laser");
          }
        }
      },
      cannon: {
        name: "Cannon Tower",
        color: "#ff8f40",
        description: "Every hit creates an explosion that damages nearby enemies.",
        range: 3.4,
        speed: 0.66,
        strength: 2,
        price: 100,
        explosionSize: 100,
        extra1: {
          description: "Explosions are increased in size.",
          price: 30,
          add: function () {
            this.explosionSize = 150;
          }
        },
        extra2: {
          description: "Explosions do as much damage as direct hits.",
          price: 75,
          add: function () {
            this.powerfulExplosions = true;
          }
        },
        power: {
          description: "Creates a giant explosion at the center of the screen that does significant damage to all enemies inside of it.",
          price: 100,
          use: function () {
            //Create an explosion centered around the target enemy
            let inExplosion = enemies.filter(enemy => Math.sqrt((960 - enemy.x) ** 2 + (450 - enemy.y) ** 2) < 400);
            inExplosion.forEach(enemy => enemy.hit(25, this, "explosion")); //Do damage to every enemy inside the explosion
            //Draw the explosion as an orange circle
            ctx.strokeStyle = "transparent";
            ctx.fillStyle = "#ff8f4055";
            ctx.drawCircle(960, 450, 400);
            sound.playSFX("explode1");
          }
        }
      },
      money: {
        name: "Money Tower",
        color: "#80ff80",
        description: "Gets 3× as much money from defeating enemies.",
        range: 3.32,
        speed: 0.88,
        strength: 1.25,
        extraMoney: true,
        price: 150,
        extra1: {
          description: "Adds an extra $10 every 10 seconds.",
          price: 300,
          add: function () {
            player.bonusMoney += 10;
          }
        },
        extra2: {
          description: "Adds an extra life every 15 seconds.",
          price: 250,
          add: function () {
            player.bonusLives += 1;
          }
        },
        power: {
          description: "Adds $100 to your total.",
          price: 380,
          use: function () {
            player.money += 100;
            sound.playSFX("coin1");
          }
        }
      },
      air: {
        name: "Air Tower",
        color: "#bfcfff",
        large: true,
        description: "Moves back and forth above the track. Has a large range and attacks quickly.",
        range: 3.61,
        speed: 2.79,
        strength: 1,
        price: 150,
        extra1: {
          description: "Every fifth hit creates a small explosion.",
          price: 25,
          add: function () {
            this.nextExplosion = 5;
          }
        },
        extra2: {
          description: "Whatever tower is closest to the plane will get a range boost.",
          price: 50,
          add: function () {
            this.rangeBoosting = true;
          }
        },
        power: {
          description: "A highly powerful plane will fly over the track, starting from the exit.",
          price: 300,
          use: function () {
            let initialX = map.start[0] * 60;
            let initialY = map.start[1] * 60;
            mapArr.forEach(direction => {
              switch (direction) {
                case "right":
                  initialX++;
                  break;
                case "left":
                  initialX--;
                  break;
                case "down":
                  initialY++;
                  break;
                case "up":
                  initialY--;
              }
            });
            superPlane = {
              initialX: initialX,
              initialY: initialY,
              distance: 0,
              range: 3.97,
              speed: 12.57,
              strength: 3.5
            }
          }
        }
      },
      ultimate: {
        name: "Ultimate Tower",
        color: "#ff6860",
        large: true,
        description: "Can rapidly destroy many enemies across a wide range.",
        range: 4.65,
        speed: 7.38,
        strength: 2,
        price: 400,
        extra1: {
          description: "Attack power is slightly increased for each enemy on the screen.",
          price: 135,
          add: function () {
            this.crowdBonus = true;
          }
        },
        extra2: {
          description: "Does 2.5× damage to boss enemies.",
          price: 1000,
          add: function () {
            this.bossBonus = true;
          }
        },
        power: {
          description: "All towers get double range, speed, and strength for 10 seconds.",
          price: 300,
          use: function () {
            towers.forEach(tower => {
              if (tower) tower.ultimateBoost = 250;
              sound.playSFX("powerUp2");
            });
          }
        }
      }
    };
    for (let type in towerTypes) {
      towerTypes[type].upgrades = {
        range: 0,
        speed: 0,
        strength: 0
      };

      //Create images for each tower type
      towerTypes[type].img = new Image();
      towerTypes[type].img.src = `../../static/img/towerdefense/${type}${type == "air" ? "-b" : ""}.png`;
      towerTypes[type].icon = new Image();
      towerTypes[type].icon.src = `../../static/img/towerdefense/${type}.png`;
      towerTypes[type].activeImg = new Image();
      towerTypes[type].activeImg.src = `../../static/img/towerdefense/${type}-active.png`;
    }

    let enemyTypes = {
      green: {
        speed: 1,
        health: 1,
        name: "Green",
        code: "g"
      },
      yellow: {
        speed: 1.5,
        health: 2,
        name: "Yellow",
        code: "y"
      },
      orange: {
        speed: 2,
        health: 3,
        name: "Orange",
        code: "o"
      },
      red: {
        speed: 2.5,
        health: 4,
        name: "Red",
        code: "r"
      },
      purple: {
        speed: 4,
        health: 2,
        name: "Purple",
        code: "p"
      },
      brown: {
        speed: 1,
        health: 10,
        name: "Brown",
        code: "b"
      },
      boss: {
        speed: 0.5,
        health: 100,
        boss: true,
        name: "Boss",
        code: "x"
      },
      brownBoss: {
        speed: 0.25,
        health: 500,
        boss: true,
        name: "Brown-boss",
        code: "z"
      },
      purpleBoss: {
        speed: 4,
        health: 100,
        boss: true,
        name: "Purple-boss",
        code: "u"
      },
    };
    for (let type in enemyTypes) {
      enemyTypes[type].img = new Image();
      enemyTypes[type].img.src = `../../static/img/towerdefense/${type}.png`;
      if (type != "green" && type != "brownBoss" && type != "purpleBoss") {
        enemyTypes[type].imgSplit = new Image();
        enemyTypes[type].imgSplit.src = `../../static/img/towerdefense/${type}-split.png`;
      }
      if (enemyTypes[type].boss) {
        enemyTypes[type].imgRotated = new Image();
        enemyTypes[type].imgRotated.src = `../../static/img/towerdefense/${type}-r.png`;
        if (type == "boss") {
          enemyTypes[type].imgSplitRotated = new Image();
          enemyTypes[type].imgSplitRotated.src = `../../static/img/towerdefense/boss-split-r.png`;
        }
      }
    }

    class Tower {
      constructor(type, row, col) {
        for (let property in type) this[property] = type[property];
        //Make new objects so towers can be upgraded independently
        this.upgrades = Object.create(this.upgrades);
        this.extra1 = Object.create(this.extra1);
        this.extra2 = Object.create(this.extra2);
        this.value = type.price;
        //Convert the tower's position from squares to pixels
        this.x = col * 60 + 30;
        this.y = row * 60 + 30;
        if (type.name == "Air Tower") {
          //Make an array of all the squares the track goes through
          let trackSquares = [];
          grid.forEach((row, i) => row.forEach((square, j) => {
            if (square == "track") trackSquares.push([j, i]);
          }));
          //The plane will appear at the nearest track square to the tower
          let closest = trackSquares.sort((a, b) => ((col - a[0]) ** 2 + (row - a[1]) ** 2) - ((col - b[0]) ** 2 + (row - b[1]) ** 2))[0];
          this.planeStartX = map.start[0] * 60;
          this.planeStartY = map.start[1] * 60;
          switch (map.lines[0][0]) {
            case "right":
              this.planeStartX += 60;
              break;
            case "left":
              this.planeStartX -= 60;
              break;
            case "down":
              this.planeStartY += 60;
              break;
            case "up":
              this.planeStartY -= 60;
          }
          this.planeDistance = 0;
          let closestX = closest[0] * 60 + 30;
          let closestY = closest[1] * 60 + 30;
          let xPos = this.planeStartX;
          let yPos = this.planeStartY;
          //Increase the plane's distance on the track until it reaches the point closest to the tower
          for (let i = 0; xPos != closestX || yPos != closestY; i++) {
            switch (planePathArr[i]) {
              case "right":
                xPos++;
                break;
              case "left":
                xPos--;
                break;
              case "down":
                yPos++;
                break;
              case "up":
                yPos--;
            }
            this.planeDistance++;
          }
        }
        this.i = towers.length;
        this.cooldown = 0; //Time until the tower can attack again
        //Display a menu with information and upgrade buttons
        this.showMenu = function () {
          if (paused) return;
          this.menuOpen = true;

          let menu = document.createElement("div");
          menu.classList.add("menu");
          menu.innerHTML = `
              <h1>${type.name}</h1>


              <h2><span id="sell" class="splitButton sellButton">
                <span class="buttonLeft">Sell</span><span class="buttonRight">+$${this.sellValue}</span>
              </span></h2>

              <h2>
                Range: ${Math.round(this.range * 100) / 100}
                <span id="range" class="splitButton">
                  <span class="buttonLeft">${(this.upgrades.range == 2 || this.range == Infinity) ? "Max" : "→&nbsp;" + Math.round(this.range * 1.25 * 100) / 100}</span><span class="buttonRight">$${this.upgradePrice("range")}</span>
                </span>
              </h2>

              <h2>
                Speed: ${Math.round(this.speed * 100) / 100}
                <span id="speed" class="splitButton">
                  <span class="buttonLeft">${(this.upgrades.speed == 2) ? "Max" : "→&nbsp;" + Math.round(this.speed * 1.5 * 100) / 100}</span><span class="buttonRight">$${this.upgradePrice("speed")}</span>
                </span>
              </h2>

              <h2>
                Strength: ${Math.round(this.strength * 100) / 100}
                <span id="strength" class="splitButton">
                  <span class="buttonLeft">${(this.upgrades.strength == 2) ? "Max" : "→&nbsp;" + Math.round(this.strength * 2 * 100) / 100}</span><span class="buttonRight">$${this.upgradePrice("strength")}</span>
                </span>
              </h2>

              <h2>
                Extra ${this.extra1.bought ? "2" : "1"}
                <span id="extra" class="splitButton">
                  <span class="buttonLeft">${this.extra2.bought ? "Bought" : "Add"}</span><span class="buttonRight">$${this.nextExtra.price}</span>
                </span>
              </h2>
              ${this.nextExtra.description ?? this.extra2.description}

              <h2>
                Special power
                <span id="power" class="splitButton">
                  <span class="buttonLeft">${difficulty == "hard" ? "Locked" : (this.power.bought ? "Bought" : "Unlock")}</span><span class="buttonRight">$${this.power.price}</span>
                </span>
              </h2>
              ${type.power.description}
            `;
          document.getElementById("container").append(menu);

          let sellButton = document.getElementById("sell");
          let rangeButton = document.getElementById("range");
          let speedButton = document.getElementById("speed");
          let strengthButton = document.getElementById("strength");
          let extraButton = document.getElementById("extra");
          let powerButton = document.getElementById("power");

          //Gray out upgrades that can't be bought
          if (player.money < this.upgradePrice("range") || this.range == Infinity) rangeButton.classList.add("unselectable");
          if (player.money < this.upgradePrice("speed")) speedButton.classList.add("unselectable");
          if (player.money < this.upgradePrice("strength")) strengthButton.classList.add("unselectable");
          if (player.money < this.nextExtra.price) extraButton.classList.add("unselectable");
          if (player.money < this.power.price || this.power.bought || difficulty == "hard") powerButton.classList.add("unselectable");

          if (this.upgrades.range == 2 || this.range == Infinity) rangeButton.classList.add("bought");
          if (this.upgrades.speed == 2) speedButton.classList.add("bought");
          if (this.upgrades.strength == 2) strengthButton.classList.add("bought");
          if (this.extra2.bought) extraButton.classList.add("bought");
          if (this.power.bought || difficulty == "hard") powerButton.classList.add("bought");

          //Center the menu horizontally
          menu.style.left = this.x / 1920 * 100 + "%";
          menu.style.transform = "translateX(-50%)";
          let menuRect = menu.getBoundingClientRect();
          let gameRect = document.getElementById("game").getBoundingClientRect();
          //If the menu is too far to the left or right, put it on the edge
          if (menuRect.x < gameRect.x) {
            menu.style.left = "0";
            menu.style.transform = "";
          } else if (menuRect.x + menuRect.width > gameRect.x + gameRect.width) {
            menu.style.left = "";
            menu.style.right = "0";
            menu.style.transform = "";
          }
          //Put the menu above or below the tower
          if (this.y > 450) menu.style.bottom = 100 - (this.y / 1080 * 100) + 10 + "%";
          else menu.style.top = this.y / 1080 * 100 + 10 + "%";

          //Remove the tower and give back 75% of all money spent on it
          sellButton.onclick = () => {
            towers[this.i] = null;
            player.money += this.sellValue;
            let row = Math.floor(this.y / 60);
            let col = Math.floor(this.x / 60);
            grid[row][col] = null; //Reset the grid square
            menu.remove();
            let squareEl = document.getElementById(`r${row}c${col}`);
            squareEl.classList.remove("tower");
            squareEl.onclick = null;
            this.menuOpen = false;
            //Remove bonuses
            if (this.name == "Money Tower") {
              if (this.extra1.bought) player.bonusMoney -= 0;
              if (this.extra2.bought) player.bonusLives -= 1;
            }
          };
          rangeButton.onclick = () => {
            if (this.upgrades.range < 2 && player.money >= this.upgradePrice("range") && this.range != Infinity) {
              player.money -= this.upgradePrice("range");
              this.value += this.upgradePrice("range");
              this.upgrades.range++;
              this.range *= 1.25;
              //Update the menu
              menu.remove();
              this.showMenu();
            }
          };
          speedButton.onclick = () => {
            if (this.upgrades.speed < 2 && player.money >= this.upgradePrice("speed")) {
              player.money -= this.upgradePrice("speed");
              this.value += this.upgradePrice("speed");
              this.upgrades.speed++;
              this.speed *= 1.5;
              //Update the menu
              menu.remove();
              this.showMenu();
            }
          };
          strengthButton.onclick = () => {
            if (this.upgrades.strength < 2 && player.money >= this.upgradePrice("strength")) {
              player.money -= this.upgradePrice("strength");
              this.value += this.upgradePrice("strength");
              this.upgrades.strength++;
              this.strength *= 2;
              //Update the menu
              menu.remove();
              this.showMenu();
            }
          };
          extraButton.onclick = () => {
            if (!this.extra2.bought && player.money >= this.nextExtra.price) {
              player.money -= this.nextExtra.price;
              this.value += this.nextExtra.price;
              this.nextExtra.add.bind(this)();
              this.nextExtra.bought = true;
              //Update the menu
              menu.remove();
              this.showMenu();
            }
          };
          powerButton.onclick = () => {
            if (!this.power.bought && player.money >= this.power.price && difficulty == "normal") {
              player.money -= this.power.price;
              this.value += this.power.price;
              this.power.bought = true;
              //Update the menu
              menu.remove();
              this.showMenu();
            }
          };

          this.closeMenu = () => {
            menu.remove();
            this.menuOpen = false;
          }
          document.getElementById("grid").onmousedown = this.closeMenu;
          document.addEventListener("keydown", e => {
            if (e.key == "Escape") this.closeMenu();
          });
        }
        this.upgradePrice = stat => {
          switch (this.upgrades[stat]) {
            case 2:
              return Infinity;
            case 1:
              return this.price * 3;
            default:
              return this.price;
          }
        }
      }

      get sellValue() {
        return Math.round(this.value * 0.75);
      }

      get nextExtra() {
        return this.extra2.bought ? { price: Infinity } : (this.extra1.bought ? this.extra2 : this.extra1);
      }
    }

    class Enemy {
      constructor(string) {
        //Set the enemy type based on the first letter
        switch (string[0]) {
          case "g":
            this.type = enemyTypes.green;
            break;
          case "y":
            this.type = enemyTypes.yellow;
            break;
          case "o":
            this.type = enemyTypes.orange;
            break;
          case "r":
            this.type = enemyTypes.red;
            break;
          case "p":
            this.type = enemyTypes.purple;
            break;
          case "b":
            this.type = enemyTypes.brown;
            break;
          case "x":
            this.type = enemyTypes.boss;
            break;
          case "z":
            this.type = enemyTypes.brownBoss;
            break;
          case "u":
            this.type = enemyTypes.purpleBoss;
        }
        this.speed = this.type.speed;
        this.health = this.type.health;
        //this.health = this.type.health * Math.ceil((currentWave + 1) / 10); //Increase enemies' HP every 10 rounds
        this.abilities = [];
        //Give the enemy an ability is there is a second character
        //Despite this.abilities being an array, an enemy can only have one ability in the current version of the game
        switch (string[1]) {
          case "h":
            this.abilities.push("healing");
            break;
          case "a":
            this.abilities.push("acceleration");
            break;
          case "s":
            this.abilities.push("split");
            break;
          case "k":
            this.abilities.push("blink");
            break;
          case "d":
            this.abilities.push("shield");
        }
        this.id = Math.random(); //Give the enemy a random ID so that no two enemy objects are identical
        this.distance = 0;
        if (this.abilities.includes("blink")) {
          this.visible = !!(blinkingCount % 2); //Every other blinking enemy will start off invisible
          if (Math.floor(frame / 100) % 2) this.visible = !this.visible; //Blinking enemies switch states every 100 frames
          blinkingCount++;
        } else {
          this.visible = true;
        }
        this.slowed = 0;
        this.poisoned = 0;
        this.noAbilities = 0;
        this.hit = function (damage, tower, type) {
          if (this.stunned) damage *= 2;
          let shieldProtection = this.abilities.includes("shield") && !this.noAbilities && type != "explosion" && type != "poison" && tower?.name != "Long-Range Tower" //Only explosions, poison, and Long-Range Towers can damage shielded enemies
          if (!shieldProtection) this.health -= damage;

          if (this.health < 0.001) {
            let i = enemies.indexOf(this);
            player.money += (this.type.boss ? 10 : 1) * (tower?.extraMoney ? 3 : 1);
            if (this.abilities.includes("split")) {
              let type;
              if (this.type == enemyTypes.boss) {
                let new1 = new Enemy("p");
                let new2 = new Enemy("p");
                let new3 = new Enemy("b");
                let new4 = new Enemy("b");
                new1.distance = this.distance;
                new2.distance = this.distance - 20;
                new3.distance = this.distance - 40;
                new4.distance = this.distance - 60;
                enemies.splice(i, 1, new1, new2, new3, new4);
              } else {
                switch (this.type) {
                  case enemyTypes.yellow:
                    type = "g";
                    break;
                  case enemyTypes.orange:
                    type = "y";
                    break;
                  case enemyTypes.red:
                    type = "o";
                    break;
                  case enemyTypes.purple:
                  case enemyTypes.brown:
                    type = "r";
                }
                let new1 = new Enemy(type);
                let new2 = new Enemy(type);
                new1.distance = this.distance;
                new2.distance = this.distance - 20;
                enemies.splice(i, 1, new1, new2);
              }
            } else {
              enemies.splice(i, 1); //Remove the enemy
            }
          } else {
            if (this.abilities.includes("acceleration") && !this.noAbilities) this.speed = this.type.speed + this.type.speed * (1 - (this.health / this.type.health)) * 3; //Normal speed + (normal speed * portion of health lost * 3)
            if (tower?.removeAbilities) this.abilities = [];
          }
        }
      }
    }

    let grid = Array(15).fill().map(() => Array(32).fill(null)); //Array containing 15 arrays (rows), each containing 32 items (columns). Makes a deep copy of each array.

    //All images used in the game except towers & enemies
    let images = {
      buttons: {
        menu: new Image(),
        pause: new Image(),
        fullscreenOn: new Image(),
        fullscreenOff: new Image(),
        soundOn: new Image(),
        soundOff: new Image(),
        alertsOn: new Image(),
        alertsOff: new Image(),
        exit: new Image(),
        play: new Image(),
        fastForward: new Image(),
        fastForwardGray: new Image(),
        playWhite: new Image(),
        fastForwardWhite: new Image(),
        dollarSign: new Image(),
        heart: new Image(),
        infinity: new Image()
      },
      abilitySymbols: {
        healing: new Image(),
        shield: new Image(),
        acceleration: new Image()
      },
      planes: {
        left: new Image(),
        right: new Image(),
        up: new Image(),
        down: new Image(),
      },
      superPlanes: {
        left: new Image(),
        right: new Image(),
        up: new Image(),
        down: new Image(),
      }
    };
    for (let button in images.buttons) images.buttons[button].src = `../../static/img/towerdefense/${button}.png`;
    for (let symbol in images.abilitySymbols) images.abilitySymbols[symbol].src = `../../static/img/towerdefense/${symbol}.png`;
    for (let plane in images.planes) images.planes[plane].src = `../../static/img/towerdefense/air-${plane}.png`;
    for (let plane in images.superPlanes) images.superPlanes[plane].src = `../../static/img/towerdefense/superPlane-${plane}.png`;

    //Sound settings and list of sound effects
    let sound = {
      enabled: localStorage.getItem("tdSound") ?? true,
      delay: 0.05, //How long each sound effect must play before it can start over
      sfx: {
        powerReady: new Audio("../../static/sound/td/td_power_ready.wav"),
        blip: new Audio("../../static/sound/td/td_blip01.wav"),
        coin1: new Audio("../../static/sound/td/td_coin01.wav"),
        coin2: new Audio("../../static/sound/td/td_coin02.wav"),
        explode1: new Audio("../../static/sound/td/td_explode01.wav"),
        explode2: new Audio("../../static/sound/td/td_explode02.wav"),
        explode3: new Audio("../../static/sound/td/td_explode03.wav"),
        laser: new Audio("../../static/sound/td/td_laser01.wav"),
        powerUp1: new Audio("../../static/sound/td/td_powerup01.wav"),
        powerUp2: new Audio("../../static/sound/td/td_powerup02.wav"),
        shoot: new Audio("../../static/sound/td/td_shoot02.wav"),
        success: new Audio("../../static/sound/td/td_success01.wav"),
        basicHit: new Audio("../../static/sound/td/td_hit01.wav"),
        slowingHit: new Audio("../../static/sound/td/td_slow_hit.wav"),
        poisonHit: new Audio("../../static/sound/td/td_poison_hit.wav"),
        moneyHit: new Audio("../../static/sound/td/td_money_hit.wav"),
        planeHit: new Audio("../../static/sound/td/td_plane_hit.wav"),
        ultimateHit: new Audio("../../static/sound/td/td_ultimate_hit.wav"),
        longRangeHit: new Audio("../../static/sound/td/td_longrange_hit.wav")
      },
      playSFX: function (name) {
        if (this.enabled) {
          let delay = this.sfx[name].delay || this.delay;
          if (this.sfx[name].currentTime >= delay) this.sfx[name].currentTime = 0;
          this.sfx[name].play();
        }
      }
    };
    //Turn down the volume of each of the sound effects
    for (const effect in sound.sfx) {
      sound.sfx[effect].volume = 0.2;
    }
    //Manually adjust some sound effects
    sound.sfx.ultimateHit.delay = sound.delay / 2;
    sound.sfx.blip.volume = 0.5;
    sound.sfx.slowingHit.volume = 0.1;
    sound.sfx.longRangeHit.volume = 0.15;
    sound.sfx.planeHit.volume = 0.15;
    sound.sfx.ultimateHit.volume = 0.4;
    sound.sfx.shoot.volume = 0.6;
    for (let type in towerTypes) towerTypes[type].hitSound = type + "Hit"; //Give all towers except for Cannon Towers different hit sounds
    towerTypes.air.hitSound = "planeHit";

    let canvas = document.getElementById("game");
    let ctx = canvas.getContext("2d");

    ctx.drawCircle = function (x, y, r) {
      this.beginPath();
      this.arc(x, y, r, 0, 2 * Math.PI);
      this.stroke();
      this.fill();
    }

    ctx.drawPath = function (instructions) {
      this.lineWidth = 1.5;
      this.strokeStyle = "#80ffff";
      this.beginPath();
      let xPos = instructions.start[0] * 60;
      let yPos = instructions.start[1] * 60;
      let col = instructions.start[0] - 0.5;
      let row = instructions.start[1] - 0.5;
      instructions.lines.forEach(line => {
        this.moveTo(xPos, yPos);
        for (let i = 0; i < line[1]; i++) {
          switch (line[0]) {
            case "right":
              xPos += 60;
              col++;
              break;
            case "left":
              xPos -= 60;
              col--;
              break;
            case "down":
              yPos += 60;
              row++;
              break;
            case "up":
              yPos -= 60;
              row--;
          }
          this.lineTo(xPos, yPos);
          if (grid[row] && grid[row][col] === null) grid[row][col] = "track"; //Change the value of every square the path goes through
        }
      });
      this.stroke();
    }

    ctx.drawPreview = function (instructions) {
      this.lineWidth = 1.5;
      this.strokeStyle = "#80ffff";
      this.beginPath();
      let xPos = instructions.start[0] * 30 + 480;
      let yPos = instructions.start[1] * 30 + 120;
      instructions.lines.forEach(line => {
        let startX = xPos;
        let startY = yPos;
        if (startX < 480) startX = 480;
        if (startX > 1440) startX = 1440;
        if (startY < 120) startY = 120;
        if (startY > 570) startY = 570;
        this.moveTo(startX, startY);
        for (let i = 0; i < line[1]; i++) {
          switch (line[0]) {
            case "right":
              xPos += 30;
              break;
            case "left":
              xPos -= 30;
              break;
            case "down":
              yPos += 30;
              break;
            case "up":
              yPos -= 30;
          }
          let endX = xPos;
          let endY = yPos;
          if (endX < 480) endX = 480;
          if (endX > 1440) endX = 1440;
          if (endY < 120) endY = 120;
          if (endY > 570) endY = 570;
          this.lineTo(endX, endY);
        }
      });
      this.stroke();
    }

    function update() {
      ctx.clearRect(0, 0, 1920, 1080); //Clear the canvas
      ctx.drawPath(map);

      //Controls menu
      ctx.drawImage(images.buttons.menu, 15, 15, 30, 30);
      document.getElementById("r0c0").classList.add("gameButton");
      document.getElementById("r0c0").onclick = () => {
        pauseGame();
        let controls = document.createElement("div");
        controls.id = "controls";

        let resume = document.createElement("div");
        resume.append(images.buttons.pause);
        resume.innerHTML += "Resume";
        resume.onclick = resumeGame;

        let speed = document.createElement("div");
        if (difficulty == "normal") {
          if (fastForward) {
            speed.append(images.buttons.fastForward);
            speed.innerHTML += "Fast forward on";
          } else {
            speed.append(images.buttons.play);
            speed.innerHTML += "Fast forward off";
          }
          speed.onclick = () => {
            fastForward = !fastForward;
            speed.innerHTML = "";
            if (fastForward) {
              speed.append(images.buttons.fastForward);
              speed.innerHTML += "Fast forward on";
            } else {
              speed.append(images.buttons.play);
              speed.innerHTML += "Fast forward off";
            }
          };
        } else {
          speed.append(images.buttons.fastForwardGray);
          speed.innerHTML += "Fast forward on";
          speed.classList.add("unselectable");
        }

        let fullscreen = document.createElement("div");
        if (document.fullscreenElement) {
          fullscreen.append(images.buttons.fullscreenOn);
          fullscreen.innerHTML += "Fullscreen on";
        } else {
          fullscreen.append(images.buttons.fullscreenOff);
          fullscreen.innerHTML += "Fullscreen off";
        }
        fullscreen.onclick = () => {
          if (document.fullscreenElement) document.exitFullscreen();
          else document.documentElement.requestFullscreen();
        };
        document.onfullscreenchange = () => {
          fullscreen.innerHTML = "";
          if (document.fullscreenElement) {
            fullscreen.append(images.buttons.fullscreenOn);
            fullscreen.innerHTML += "Fullscreen on";
          } else {
            fullscreen.append(images.buttons.fullscreenOff);
            fullscreen.innerHTML += "Fullscreen off";
          }
        }

        let volume = document.createElement("div");
        if (sound.enabled) {
          volume.append(images.buttons.soundOn);
          volume.innerHTML += "Sound on";
        } else {
          volume.append(images.buttons.soundOff);
          volume.innerHTML += "Sound off";
        }
        volume.onclick = () => {
          sound.enabled = !sound.enabled;
          volume.innerHTML = "";
          if (sound.enabled) {
            localStorage.setItem("tdSound", "true");
            volume.append(images.buttons.soundOn);
            volume.innerHTML += "Sound on";
          } else {
            localStorage.setItem("tdSound", "");
            volume.append(images.buttons.soundOff);
            volume.innerHTML += "Sound off";
          }
        }

        let alerts = document.createElement("div");
        if (alertsOn) {
          alerts.append(images.buttons.alertsOn);
          alerts.innerHTML += "Alerts on";
        } else {
          alerts.append(images.buttons.alertsOff);
          alerts.innerHTML += "Alerts off";
        }
        alerts.onclick = () => {
          alertsOn = !alertsOn;
          alerts.innerHTML = "";
          if (alertsOn) {
            localStorage.setItem("tdAlerts", "true");
            alerts.append(images.buttons.alertsOn);
            alerts.innerHTML += "Alerts on";
          } else {
            localStorage.setItem("tdAlerts", "");
            alerts.append(images.buttons.alertsOff);
            alerts.innerHTML += "Alerts off";
          }
        }

        controls.append(resume, speed, fullscreen, volume, alerts);

        if (testing) {
          let infiniteMoney = document.createElement("div");
          if (player.money == Infinity) {
            infiniteMoney.append(images.buttons.infinity);
            infiniteMoney.innerHTML += "Infinite money on";
          } else {
            infiniteMoney.append(images.buttons.dollarSign);
            infiniteMoney.innerHTML += "Infinite money off";
          }
          infiniteMoney.onclick = () => {
            infiniteMoney.innerHTML = "";
            if (player.money < Infinity) {
              player.money = Infinity;
              infiniteMoney.append(images.buttons.infinity);
              infiniteMoney.innerHTML += "Infinite money on";
            } else {
              player.money = 75;
              infiniteMoney.append(images.buttons.dollarSign);
              infiniteMoney.innerHTML += "Infinite money off";
            }
          };
          
          let infiniteLives = document.createElement("div");
          if (player.lives == Infinity) {
            infiniteLives.append(images.buttons.infinity);
            infiniteLives.innerHTML += "Infinite lives on";
          } else {
            infiniteLives.append(images.buttons.heart);
            infiniteLives.innerHTML += "Infinite lives off";
          }
          infiniteLives.onclick = () => {
            infiniteLives.innerHTML = "";
            if (player.lives < Infinity) {
              player.lives = Infinity;
              infiniteLives.append(images.buttons.infinity);
              infiniteLives.innerHTML += "Infinite lives on";
            } else {
              player.lives = 100;
              infiniteLives.append(images.buttons.heart);
              infiniteLives.innerHTML += "Infinite lives off";
            }
          };

          controls.append(infiniteMoney, infiniteLives);
        }

        let exit = document.createElement("div");
        exit.append(images.buttons.exit);
        if (testing) {
          exit.innerHTML += "Return to editor";
          exit.onclick = () => {
            resumeGame();
            endGame();
            if (document.getElementById("lightBackground")) {
              document.getElementById("lightBackground").classList.remove("hidden");
              document.getElementById("visual").classList.remove("hidden");
              document.getElementById("text").classList.remove("hidden");
            } else {
              openEditor();
            }
          };
        } else {
          exit.innerHTML += "Exit game";
          exit.onclick = () => window.location.reload();
        }
        controls.append(exit);

        document.getElementById("container").append(controls);
        document.getElementById("grid").onmouseup = function() {
          this.onclick = resumeGame;
        };
        document.addEventListener("keydown", e => {
          if (e.key == "Escape") resumeGame();
        });
      };

      //Fast forward button
      if (difficulty == "normal") {
        ctx.drawImage(fastForward ? images.buttons.playWhite : images.buttons.fastForwardWhite, 75, 15, 30, 30);
        document.getElementById("r0c1").classList.add("gameButton");
        document.getElementById("r0c1").onclick = () => {
          fastForward = !fastForward;
          if (paused) {
            resumeGame();
          } else {
            clearInterval(animate);
            animate = setInterval(update, fastForward ? 10 : 40);
          }
        };
      }

      if (dragOver && dragOver[0].name != "Air Tower") {
        ctx.lineWidth = 1;
        ctx.strokeStyle = "white";
        ctx.fillStyle = "#aaa5";
        ctx.drawCircle(dragOver[1] * 60 + 30, dragOver[2] * 60 + 30, dragOver[0].range * 60);
      }

      //Spawn enemies
      if (!(frame % 4)) { //Do this every 4 frames
        let next = map.waves[currentWave][currentEnemy];
        while (Array.isArray(next)) {
          if (next[0] == "alert") {
            if (alertsOn) gameAlert(next[1]);
            map.waves[currentWave].splice(currentEnemy, 1); //Remove the array
          } else {
            let repeat = next[0]; //The array's first item is the number of times to repeat
            let items = next.slice(1); //Everything that follows is repeated
            let repeated = Array(repeat).fill(items).flat(); //Make an array containing the items array repeated, then flatten it
            map.waves[currentWave].splice(currentEnemy, 1, ...repeated); //Add each item in repeated to the wave and remove the array
          }
          next = map.waves[currentWave][currentEnemy];
        }
        //Add next enemy
        if (next) {
          let newEnemy = new Enemy(next);
          enemies.push(newEnemy);
        }

        if (map.waves[currentWave][currentEnemy + 1] !== undefined) { //If there are enemies left in the wave
          currentEnemy++;
        } else {
          if (!map.waves[currentWave + 1]) { //If there are no waves left
            //Once all enemies are defeated, end the game
            if (enemies.length) {
              map.waves[currentWave].push(null);
            } else {
              endGame(true);
              return;
            }
          } else {
            currentWave++;
            currentEnemy = 0;
          }
          //if (currentWave == 50) for (let type in enemyTypes) enemyTypes[type].health *= 2; //All enemy types get double health for the last 25 rounds of hard mode
        }
      }

      enemies.forEach((enemy, i) => {
        //If the enemy is at the end of the track, subtract a life and remove it from the array
        //Otherwise, draw it in its new position
        if (enemy.distance >= mapArr.length) {
          player.lives -= enemy.type.health;
          if (player.lives) sound.playSFX("blip");
          gameAchievements[0] = 0;
          enemies.splice(i, 1);
        } else {
          if (enemy.reverse) {
            enemy.distance -= enemy.speed * (enemy.slowed ? 2 : 4);
            enemy.reverse--;
          } else if (enemy.stunned) {
            enemy.stunned--;
          } else {
            enemy.distance += enemy.speed * (enemy.slowed ? 2 : 4);
          }
          if (enemy.slowed) enemy.slowed--;
          if (enemy.poisoned && --enemy.poisoned % (enemy.doublePoisoned ? 12.5 : 25) < 1) enemy.hit(0.6, null, "poison");
          if (enemy.doublePoisoned) enemy.doublePoisoned--;

          enemy.x = map.start[0] * 60;
          enemy.y = map.start[1] * 60;
          let img = enemy.type.img;
          for (let j = 0; j < Math.round(enemy.distance); j++) {
            //Move the enemy forward
            switch (mapArr[j]) {
              case "right":
                enemy.x++;
                break;
              case "left":
                enemy.x--;
                break;
              case "down":
                enemy.y++;
                break;
              case "up":
                enemy.y--;
            }
            if (enemy.abilities.includes("split")) {
              img = (enemy.type.boss && (mapArr[j] == "right" || mapArr[j] == "left")) ? enemy.type.imgSplitRotated : enemy.type.imgSplit; //If the enemy is a boss and moving horizontally, rotate it
            } else if (enemy.type.boss && (mapArr[j] == "right" || mapArr[j] == "left")) {
              img = enemy.type.imgRotated;
            } else {
              img = enemy.type.img;
            }
          }
          if (!enemy.visible) ctx.globalAlpha = 0.25; //If the enemy is hidden, make it semitransparent
          ctx.drawImage(img, enemy.x - 40, enemy.y - 40);
          ctx.globalAlpha = 1;
          //Draw ability symbols inside the enemy
          if (enemy.abilities.includes("healing") && !enemy.noAbilities) ctx.drawImage(images.abilitySymbols.healing, enemy.x - 40, enemy.y - 40);
          if (enemy.abilities.includes("shield") && !enemy.noAbilities) ctx.drawImage(images.abilitySymbols.shield, enemy.x - 40, enemy.y - 40);
          if (enemy.abilities.includes("acceleration") && !enemy.noAbilities) ctx.drawImage(images.abilitySymbols.acceleration, enemy.x - 40, enemy.y - 40);
        }

        if (enemy.abilities.includes("healing") && enemy.health < enemy.type.health && !enemy.noAbilities) {
          enemy.health += 1 / 75;
          if (enemy.health > enemy.type.health) enemy.health = enemy.type.health; //Don't let the enemy's health go above the initial value
        }
        if (enemy.abilities.includes("blink")) {
          if (!(frame % 100)) enemy.visible = !enemy.visible;
        } else {
          enemy.visible = true;
        }
        if (enemy.noAbilities) enemy.visible = true;

        if (enemy.noAbilities) enemy.noAbilities--;
      });

      towers.forEach(tower => {
        if (!tower) return; //If the tower has been sold, skip this
        ctx.drawImage(tower.img, tower.x - 30, tower.y - 30);

        if (tower.name == "Air Tower") {
          tower.planeDistance += 8;
          tower.planeX = tower.planeStartX;
          tower.planeY = tower.planeStartY;
          let img;
          for (let i = 0; i < Math.round(tower.planeDistance); i++) {
            let j = i;
            while (j >= planePathArr.length) j -= planePathArr.length;
            switch (planePathArr[j]) {
              case "right":
                tower.planeX++;
                break;
              case "left":
                tower.planeX--;
                break;
              case "down":
                tower.planeY++;
                break;
              case "up":
                tower.planeY--;
            }
            img = images.planes[planePathArr[j]];
          }
          ctx.drawImage(img, tower.planeX - 30, tower.planeY - 30);
        }

        if (tower.menuOpen) {
          //Show the tower's range
          ctx.lineWidth = 1;
          ctx.strokeStyle = "white";
          ctx.fillStyle = "#aaa5";
          let x = (tower.name == "Air Tower") ? tower.planeX : tower.x;
          let y = (tower.name == "Air Tower") ? tower.planeY : tower.y;
          let range = tower.range;
          if (towers.find(owned => owned?.rangeBoosted == tower)) range *= 1.25;
          if (tower.ultimateBoost) range *= 2;
          ctx.drawCircle(x, y, range * 60);
        }

        if (tower.rangeBoosting) {
          let otherTowers = towers.filter(owned => owned && owned != tower && owned.range != Infinity); //Remove this tower, sold towers, and Long-Range Towers
          let closest = otherTowers.sort((a, b) => ((tower.planeX - a.x) ** 2 + (tower.planeY - a.y) ** 2) - ((tower.planeX - b.x) ** 2 + (tower.planeY - b.y) ** 2))[0];
          tower.rangeBoosted = closest;
        }

        if (tower.cooldown > 1) {
          let reduceCooldown = 1;
          if (tower.speedBoost) reduceCooldown *= 5;
          if (tower.ultimateBoost) reduceCooldown *= 2;
          tower.cooldown -= reduceCooldown;
        } else {
          let x = (tower.name == "Air Tower") ? tower.planeX : tower.x;
          let y = (tower.name == "Air Tower") ? tower.planeY : tower.y;
          let range = tower.range;
          if (towers.find(owned => owned?.rangeBoosted == tower)) range *= 1.25; //Range boost from Air Tower
          if (tower.ultimateBoost) range *= 2;
          let inRange = enemies.filter(enemy => Math.sqrt((x - enemy.x) ** 2 + (y - enemy.y) ** 2) < range * 60); //Use the Pythagorean Theorem to determine if each enemy is inside the tower's range
          if (!tower.seeInvisible) inRange = inRange.filter(enemy => enemy.visible);
          if (inRange.length) {
            let furthest = inRange.sort((a, b) => b.distance - a.distance)[0]; //Sort inRange from highest to lowest distance and get the first item
            let strong = inRange.sort((a, b) => b.health - a.health); //Sort inRange from highest to lowest health
            let strongest = strong.find(enemy => enemy.abilities.includes("shield")) || strong[0]; //Target shielded enemies
            let target = (tower.name == "Long-Range Tower") ? strongest : furthest;
            let damage = tower.strength;
            if (tower.crowdBonus) damage *= 1 + enemies.length / 100; //Increase the damage by 1% for each enemy onscreen
            if (tower.bossBonus && target.type.boss) damage *= 2.5;
            if (tower.ultimateBoost) damage *= 2;
            target.hit(damage, tower);

            if (sound.sfx[tower.hitSound]) sound.playSFX(tower.hitSound, tower.name); //Play hit sound

            if (tower.slowing && !target.abilities.includes("acceleration")) target.slowed = tower.permSlow ? Infinity : Math.max(target.slowed, 250);
            if (tower.abilityBlocking && !target.abilities.includes("acceleration")) target.noAbilities = tower.permSlow ? Infinity : Math.max(target.noAbilities, 250);
            if (tower.poison && !target.abilities.includes("healing")) {
              target.poisoned = 125; //Poison the target for 125 frames
              if (tower.doublePoison) target.doublePoisoned = 125;
            }
            if (tower.bounce) {
              let bouncePath = [target]; //Make an array of all enemies hit so they aren't bounced to again
              let close = enemies.filter(enemy => Math.sqrt((target.x - enemy.x) ** 2 + (target.y - enemy.y) ** 2) < 100 && !bouncePath.includes(enemy) && enemy.visible);
              let bouncesLeft = tower.bounce;
              while (close.length && bouncesLeft) { //While the projectile can still bounce and there are enemies to bounce to
                let closest = close.sort((a, b) => ((target.x - a.x) ** 2 + (target.y - a.y) ** 2) - ((target.x - b.x) ** 2 + (target.y - b.y) ** 2))[0];
                let distance = Math.sqrt((target.x - closest.x) ** 2 + (target.y - closest.y) ** 2);
                let oldTarget = target;
                target = closest;

                ctx.lineWidth = 4;
                ctx.strokeStyle = tower.color;
                ctx.beginPath();
                ctx.moveTo(oldTarget.x, oldTarget.y);
                ctx.lineTo(target.x, target.y);
                ctx.stroke();

                damage = tower.strength;
                if (tower.ultimateBoost) damage *= 2;
                target.hit(damage, tower);
                bouncePath.push(target);
                close = enemies.filter(enemy => Math.sqrt((target.x - enemy.x) ** 2 + (target.y - enemy.y) ** 2) < 100 && !bouncePath.includes(enemy) && enemy.visible);
                bouncesLeft--;
              }
            }
            if (tower.poisonSplash) {
              let close = enemies.filter(enemy => Math.sqrt((target.x - enemy.x) ** 2 + (target.y - enemy.y) ** 2) < 100 && enemy != target && enemy.visible);
              if (close.length) {
                let closest = close.sort((a, b) => ((target.x - a.x) ** 2 + (target.y - a.y) ** 2) - ((target.x - b.x) ** 2 + (target.y - b.y) ** 2))[0];
                let distance = Math.sqrt((target.x - closest.x) ** 2 + (target.y - closest.y) ** 2);
                target = closest;
                target.poisoned = 125;
                if (tower.doublePoison) target.doublePoisoned = 125;
              }
            }
            if (tower.nextExplosion === 0) tower.explosionSize = 75;
            if (tower.explosionSize) { //If the hit causes an explosion
              //Create an explosion centered around the target enemy
              let inExplosion = enemies.filter(enemy => Math.sqrt((target.x - enemy.x) ** 2 + (target.y - enemy.y) ** 2) < tower.explosionSize);
              let explosionDamage = tower.powerfulExplosions ? tower.strength : 1;
              inExplosion.forEach(enemy => enemy.hit(explosionDamage, tower, "explosion")); //Do damage to every enemy inside the explosion
              //Draw the explosion as an orange circle
              ctx.strokeStyle = "transparent";
              ctx.fillStyle = "#ff8f4055";
              ctx.drawCircle(target.x, target.y, tower.explosionSize);
              sound.playSFX("explode1");
            }
            if (tower.nextExplosion) {
              tower.nextExplosion--;
            } else if (tower.nextExplosion === 0) {
              delete tower.explosionSize;
              tower.nextExplosion = 5;
            }

            ctx.drawImage(tower.activeImg, tower.x - 30, tower.y - 30); //Light up the firing tower for 1 frame

            //Draw line of fire
            ctx.lineWidth = 4;
            ctx.strokeStyle = tower.color;
            ctx.beginPath(); //Start a new path
            if (tower.name == "Air Tower") ctx.moveTo(tower.planeX, tower.planeY);
            else ctx.moveTo(tower.x, tower.y);
            ctx.lineTo(target.x, target.y);
            ctx.stroke(); //Render the path

            tower.cooldown += 25 / tower.speed;
          }
        }

        if (tower.speedBoost) tower.speedBoost--;
        if (tower.ultimateBoost) tower.ultimateBoost--;

        if (tower.upgrades.range == 2 && tower.upgrades.speed == 2 && tower.upgrades.strength == 2 && tower.extra2.bought) gameAchievements[2] = 1;
      });

      if (superPlane) {
        superPlane.distance += 12;
        if (superPlane.distance > superPlanePathArr.length) {
          superPlane = null;
        } else {
          superPlane.x = superPlane.initialX;
          superPlane.y = superPlane.initialY;
          let img;
          for (let i = 0; i < Math.round(superPlane.distance); i++) {
            switch (superPlanePathArr[i]) {
              case "right":
                superPlane.x++;
                break;
              case "left":
                superPlane.x--;
                break;
              case "down":
                superPlane.y++;
                break;
              case "up":
                superPlane.y--;
            }
            img = images.superPlanes[superPlanePathArr[i]];
          }
          ctx.drawImage(img, superPlane.x - 45, superPlane.y - 45);

          if (superPlane.cooldown > 1) {
            superPlane.cooldown--;
          } else {
            let inRange = enemies.filter(enemy => Math.sqrt((superPlane.x - enemy.x) ** 2 + (superPlane.y - enemy.y) ** 2) < superPlane.range * 60 && enemy.visible);
            if (inRange.length) {
              let target = inRange.sort((a, b) => b.distance - a.distance)[0];
              target.hit(superPlane.strength);
              sound.playSFX("planeHit");
              ctx.lineWidth = 4;
              ctx.strokeStyle = "#ff6860";
              ctx.beginPath();
              ctx.moveTo(superPlane.x, superPlane.y);
              ctx.lineTo(target.x, target.y);
              ctx.stroke();

              superPlane.cooldown += 25 / superPlane.speed;
            }
          }
        }
      }

      for (let tower in towerTypes) {
        let towerEl = document.getElementById(tower);

        if (towerTypes[tower].power.cooldown) {
          towerTypes[tower].power.cooldown--;
          if (!towerTypes[tower].power.cooldown) {
            let powerEl = document.getElementById(tower + "Power");
            powerEl.classList.add("powerReady");
            setTimeout(() => powerEl.classList.remove("powerReady"), 1000);
            sound.playSFX("powerReady");
          }
        }

        if (player.money >= towerTypes[tower].price) {
          towerEl.classList.remove("unselectable");
          towerEl.draggable = true;
          //Do this when the tower is picked up
          towerEl.ondragstart = () => {
            //If a tower's menu is open, close it
            let menuTower = towers.find(tower => tower?.menuOpen);
            menuTower?.closeMenu();
            towerTypes[tower].dragging = true;
            document.getElementById("grid").classList.add("visibleLines"); //Show the grid's lines
            grid.forEach((row, i) => row.forEach((square, j) => {
              let squareEl = document.getElementById("r" + i + "c" + j);
              if (square) { //If the square is not null
                squareEl.ondragover = () => squareEl.classList.add("undroppable");
                squareEl.ondragleave = () => squareEl.classList.remove("undroppable");
                squareEl.ondrop = () => squareEl.classList.remove("undroppable");
              } else {
                squareEl.ondragover = () => {
                  event.preventDefault();
                  squareEl.classList.add("droppable");
                  dragOver = [towerTypes[tower], j, i]; //Save the tower being dragged, the column, and the row
                };
                squareEl.ondragleave = () => {
                  squareEl.classList.remove("droppable");
                  dragOver = null;
                };
                squareEl.ondrop = () => {
                  squareEl.classList.remove("droppable");
                  dragOver = null;
                  document.getElementById("grid").classList.remove("visibleLines");
                  if (player.money >= towerTypes[tower].price) { //Check that the player can afford the tower again to prevent cheating
                    //Place the tower
                    player.money -= towerTypes[tower].price;
                    let newTower = new Tower(towerTypes[tower], i, j);
                    towers.push(newTower);
                    grid[i][j] = newTower;
                    let squareEl = document.getElementById("r" + i + "c" + j);
                    squareEl.classList.add("tower");
                    squareEl.onclick = () => newTower.showMenu();
                    towerTypes[tower].placed = true;
                    if (Object.values(towerTypes).every(tower => tower.placed)) gameAchievements[1] = 1;
                    if (newTower.name == "Ultimate Tower") gameAchievements[4] = 0;
                    if (newTower.name == "Basic Tower") gameAchievements[5] = 0;
                    if (towers.length == 4) gameAchievements[6] = 0;
                  }
                };
              }
            }));
          };
          towerEl.ondragend = () => {
            delete towerTypes[tower].dragging;
            dragOver = null;
            document.getElementById("grid").classList.remove("visibleLines");
            grid.forEach((row, i) => row.forEach((square, j) => {
              let squareEl = document.getElementById("r" + i + "c" + j);
              squareEl.ondragover = null;
              squareEl.ondragleave = null;
              squareEl.ondrop = null;
            }));
          };
        } else {
          towerEl.classList.add("unselectable");
          towerEl.draggable = false;
        }

        let power = towerTypes[tower].power;
        let powerButton = document.getElementById(tower + "Power");
        if (power.bought && towers.find(owned => owned?.name == towerTypes[tower].name)) {
          powerButton.classList.remove("invisible");
          if (power.cooldown) {
            powerButton.classList.add("unselectable");
            let percent = power.cooldown / 3000 * 100;
            powerButton.style.background = `linear-gradient(to left, var(--emphasis-color), var(--emphasis-color) ${percent}%, gray ${percent}%)`; //Show how long until the power can be used again
          } else {
            powerButton.style.background = null; //Reset the background
            powerButton.classList.remove("unselectable");
          }
        } else {
          powerButton.classList.add("invisible");
        }
      }

      if (!(frame % 250)) player.money += player.bonusMoney;
      if (!(frame % 375)) player.lives += player.bonusLives;

      let menuTower = towers.find(tower => tower?.menuOpen);
      if (menuTower) {
        if (player.money >= menuTower.upgradePrice("range") && menuTower.range !== Infinity) document.getElementById("range").classList.remove("unselectable");
        if (player.money >= menuTower.upgradePrice("speed")) document.getElementById("speed").classList.remove("unselectable");
        if (player.money >= menuTower.upgradePrice("strength")) document.getElementById("strength").classList.remove("unselectable");
        if (player.money >= menuTower.nextExtra.price) document.getElementById("extra").classList.remove("unselectable");
        if (player.money >= menuTower.power.price && !menuTower.power.bought && difficulty == "normal") document.getElementById("power").classList.remove("unselectable");
      }

      //Update text in top-right
      ctx.font = "30px monospace";
      ctx.textAlign = "left";
      if (player.lives > 0) {
        //Display time, money, and lives in the top-right corner
        ctx.fillStyle = "#ddd";
        ctx.fillText(`${(currentWave + 1).toString().padStart(2, "0")}/${map.waves.length}`, 1564, 40); //Show current and total waves
        ctx.fillStyle = "#80ff80";
        ctx.fillText("$" + ((player.money == Infinity) ? "-----" : player.money.toString().padStart(5, "0")), 1684, 40);
        ctx.fillStyle = "#ff6860";
        ctx.fillText("❤︎" + ((player.lives == Infinity) ? "---" : player.lives.toString().padStart(3, "0")), 1820, 40);
      } else {
        endGame();
      }

      frame++;
    }

    let savedProgress = "{{ progress }}".replaceAll("&#34;", "\""); //2 means map completed on hard, 1 means map completed on normal, 0 means map not completed, L means map is locked
    let achievements = "{{ achievements }}" || "0000000"; //1 means earned, 0 means not earned
    achievements = achievements.split("");
    let player = {
      money: 75,
      lives: 100,
      bonusMoney: 0,
      bonusLives: 0
    };
    let mapIndex = 0;
    let map;
    let mapArr;
    let planePathArr;
    let superPlanePathArr;
    let difficulty = "normal";
    let gameAchievements = [1, 0, 0, 0, 1, 1, 1];
    let enemies = [];
    let blinkingCount = 0; //Keep track of blinking enemies to alternate between visible and invisible
    let towers = [];
    let frame = 0;
    let currentWave = 0;
    let currentEnemy = 0;
    let superPlane;
    let paused;
    let fastForward = false;
    let alertsOn = localStorage.getItem("tdAlerts") ?? true;
    let dragOver;
    let animate;
    let testing;
    let clearCheck;

    let progress = {};
    try {
      savedProgress = JSON.parse(savedProgress); //New object format
    } catch {
      //Old string format; do nothing
    }
    maps.forEach((mapObj, i) => {
      let mapNum = mapObj.id || i; //If the map doesn't have an id, use its index in the maps array instead (only maps from the editor have ids)
      progress[mapNum] = savedProgress[mapNum];
      if (progress[mapNum] == "L" && !+mapObj.digipogs) progress[mapNum] = "0"; //Unlock maps if they become free
      progress[mapNum] ??= +mapObj.digipogs ? "L" : "0";
    });
    request.open("POST", "/updateuser?field=tdProgress&value=" + JSON.stringify(progress));
    request.send();

    let achievementList = [
      "Complete a game without losing any lives",
      "Purchase every tower type in one game",
      "Fully upgrade a tower",
      "Use every special power in one game",
      "Win a game without any Ultimate Towers",
      "Win a game without any Basic Towers",
      "Win a game without placing more than three towers"
    ];

    //Create the title
    ctx.drawPreview({
      start: [1, 3],
      lines: [
        ["right", 1],
        ["up", 1],
        ["down", 1],
        ["right", 1],
        ["left", 1],
        ["down", 3],
        ["right", 2],
        ["up", 2],
        ["right", 2],
        ["down", 2],
        ["left", 2],
        ["up", 2],
        ["right", 3],
        ["down", 2],
        ["right", 1],
        ["up", 1],
        ["down", 1],
        ["right", 1],
        ["up", 2],
        ["right", 1],
        ["down", 1],
        ["right", 1],
        ["up", 1],
        ["left", 1],
        ["down", 2],
        ["right", 2],
        ["up", 2],
        ["right", 1],
        ["down", 1],
      ]
    });
    ctx.drawPreview({
      start: [17, 2],
      lines: [
        ["down", 4],
        ["left", 2],
        ["up", 2],
        ["right", 3],
        ["down", 1],
        ["right", 1],
        ["up", 1],
        ["left", 1],
        ["down", 2],
        ["right", 2],
        ["up", 4],
        ["right", 1],
        ["down", 1],
        ["up", 1],
        ["left", 1],
        ["down", 2],
        ["right", 2],
        ["down", 1],
        ["right", 1],
        ["up", 1],
        ["left", 1],
        ["down", 2],
        ["right", 2],
        ["up", 2],
        ["right", 2],
        ["down", 2],
        ["right", 2],
        ["up", 1],
        ["left", 1],
        ["up", 1],
        ["right", 2],
        ["down", 1],
        ["right", 1],
        ["up", 1],
        ["left", 1],
        ["down", 2],
        ["right", 2]
      ]
    });
    ctx.fillStyle = "white";
    ctx.textAlign = "center";
    let playButton = document.createElement("button");
    playButton.id = "playButton";
    playButton.classList.add("hCentered");
    playButton.innerText = "Play";
    playButton.onclick = showMaps;
    document.getElementById("container").append(playButton);
    let editorButton = document.createElement("button");
    editorButton.id = "editorButton";
    editorButton.classList.add("hCentered");
    editorButton.innerText = "Map editor";
    editorButton.onclick = openEditor;
    document.getElementById("container").append(editorButton);
    ctx.font = "32px Segoe UI";
    ctx.fillText("Created by Oley Birkeland", 960, 1000);
    let completeMaps = Object.values(progress).filter(char => char != "L").reduce((a, b) => +a + +b); //Convert every character to a number and add
    let totalMaps = maps.length * 2;
    let completeAchv = achievements.reduce((a, b) => +a + +b);
    let totalAchv = achievementList.length;
    let progressEl = document.getElementById("progress");
    if (completeMaps == totalMaps && completeAchv == totalAchv) progressEl.classList.add("complete");
    let progressText = document.createElement("span");
    progressText.id = "progressText";
    progressText.innerText = `${completeMaps}/${totalMaps} complete`;
    progressEl.append(progressText);
    let achvText = document.createElement("div");
    achvText.id = "achievements";
    achvText.innerHTML = `<span>${completeAchv}/${totalAchv} achievements</span>`;
    let achvButton = document.createElement("button");
    achvButton.id = "achvButton";;
    achvButton.innerText = "Open list";
    achvButton.onclick = () => {
      let listText = "<ul>";
      achievementList.forEach((achievement, i) => {
        let earned = +achievements[i];
        let tag = earned ? "s" : "b";
        listText += `<li class=${earned ? "earned" : ""}><${tag}>${achievement}</${tag}></li>`;
      });
      listText += "</ul>";
      gameAlert(listText, "alert", "large");
    }
    achvText.append(achvButton);
    progressEl.append(achvText);

    function showMaps() {
      document.getElementById("progress").remove();
      document.getElementById("playButton").remove();
      document.getElementById("editorButton").remove();
      if (document.getElementById("alert")) resumeGame();
      ctx.clearRect(0, 0, 1920, 1080); //Clear the canvas

      let back = document.createElement("div");
      back.id = "back";
      back.innerText = "🡄";
      back.onclick = () => window.location.reload();

      let removeButton = new Image();
      removeButton.id = "removeButton";
      removeButton.classList.add("hidden");
      if ({{perms}} < 2) { //Teachers and mods can remove maps
        removeButton.src = "../../static/img/towerdefense/remove.png";
        removeButton.onclick = removeMap;
      } else {
        removeButton.src = "../../static/img/towerdefense/removeReq.png";
        removeButton.onclick = requestRemoval;
      }

      let left = document.createElement("div");
      let right = document.createElement("div");
      left.id = "prevMap";
      right.id = "nextMap";
      left.innerText = "◀";
      right.innerText = "▶";
      left.onclick = () => {
        (mapIndex == 0) ? mapIndex = maps.length - 1 : mapIndex--;
        switchMap();
      }
      right.onclick = () => {
        (mapIndex == maps.length - 1) ? mapIndex = 0 : mapIndex++;
        switchMap();
      }

      let difficultyButtons = document.createElement("div");
      difficultyButtons.id = "difficulty";
      difficultyButtons.innerText = "Difficulty: ";
      let normal = document.createElement("button");
      let hard = document.createElement("button");
      normal.id = "normal";
      hard.id = "hard";
      normal.innerText = "Normal";
      hard.innerText = "Hard";
      normal.onclick = () => {
        difficulty = "normal";
        switchDifficulty();
      };
      hard.onclick = () => {
        difficulty = "hard";
        switchDifficulty();
      };
      difficultyButtons.append(normal, hard);

      let startButton = document.createElement("button");
      startButton.id = "startButton";
      startButton.classList.add("hCentered");
      startButton.innerText = "Start game";

      document.getElementById("container").append(back, removeButton, left, right, difficultyButtons, startButton);

      switchMap();
    }

    function switchMap() {
      map = maps[mapIndex];
      ctx.clearRect(0, 0, 1920, 570);
      ctx.fillStyle = "white";
      ctx.font = "48px Segoe UI";
      ctx.textAlign = "center";
      ctx.fillText(`${map.name} by ${map.author}`, 960, 75);
      try {
        ctx.drawPreview(map); //Draw preview of map
      } catch {}
      ctx.strokeStyle = "white";
      ctx.lineWidth = 2;
      ctx.strokeRect(480, 120, 960, 450);
      switchDifficulty();
      let removeButton = document.getElementById("removeButton");
      //Only maps from the editor can be removed
      if (map.id && map.author != "{{ username }}") removeButton.classList.remove("hidden");
      else removeButton.classList.add("hidden");
    }

    function switchDifficulty() {
      let normal = document.getElementById("normal");
      let hard = document.getElementById("hard");
      let startButton = document.getElementById("startButton");
      let mapComplete = +progress[map.id || mapIndex];
      ctx.clearRect(0, 675, 1920, 275);
      ctx.fillStyle = "white";
      ctx.font = "30px Segoe UI";
      if (difficulty == "normal") {
        normal.classList.add("pressed");
        hard.classList.remove("pressed");
        ctx.fillText("• 50 waves", 960, 700);
        ctx.fillText("• 100 lives", 960, 750);
        if (mapComplete) {
          ctx.fillStyle = "#80ff80";
          ctx.fillText("✔️ Normal mode complete", 960, 935);
        }
        if (isNaN(mapComplete)) {
          ctx.fillStyle = "#ff6860";
          ctx.fillText(`🔒 ${map.digipogs} digipogs to unlock`, 960, 935);
        }
      } else {
        hard.classList.add("pressed");
        normal.classList.remove("pressed");
        ctx.fillText("• 75 waves", 960, 700);
        ctx.fillText("• 50 lives", 960, 750);
        ctx.fillText("• No special powers", 960, 800);
        ctx.fillText("• Fast forward permanently on", 960, 850);
        if (mapComplete == 2) {
          ctx.fillStyle = "#80ff80";
          ctx.fillText("✔️ Hard mode complete", 960, 935);
        } else if (!mapComplete) {
          ctx.fillStyle = "#ff6860";
          ctx.fillText("🔒 Complete normal mode to unlock hard mode", 960, 935);
          startButton.classList.add("unselectable");
          startButton.onclick = null;
        }
      }
      if (isNaN(mapComplete)) {
        startButton.innerText = "Buy map";
        startButton.classList.remove("unselectable");
        startButton.onclick = buyMap;
      } else if (difficulty == "normal" || mapComplete) {
        startButton.innerText = "Start game";
        startButton.classList.remove("unselectable");
        startButton.onclick = startGame;
      }
    }

    //This is how you use the /spenddp endpoint
    async function buyMap() {
      let response = await getResponse("/spenddp?amount=" + map.digipogs);
      if (response.result == "success") {
        gameAlert(`Buy ${map.name} for ${map.digipogs} digipogs?`, "confirm", "normal", () => {
          progress[map.id || mapIndex] = "0"; //Update progress
          //Save to the database as a string
          let request1 = new XMLHttpRequest();
          request1.open("POST", "/updateuser?field=tdProgress&value=" + JSON.stringify(progress));
          request1.send();
          switchMap();
        });
      } else {
        if (response.reason == "not enough digipogs") gameAlert("Not enough digipogs.");
        if (response.reason == "database error") gameAlert("Guests can't spend digipogs.");
      }
    }

    function requestRemoval() {
      document.getElementById("removeBox")?.remove();
      document.getElementById("alertCover")?.remove();
      let cover = document.createElement("div");
      cover.id = "alertCover";
      let removeBox = document.createElement("div");
      removeBox.id = "removeBox";
      removeBox.classList.add("centered");
      removeBox.innerHTML = `
        <h2>Request map removal</h2><br>
        Reason: <input id="reason" class="box" type="text"><br><br>
        Your request to remove ${map.name} will be sent to the teacher as a chat message.
      `;
      let cancelButton = document.createElement("button");
      cancelButton.id = "cancel";
      cancelButton.innerText = "Cancel";
      cancelButton.onclick = () => {
        removeBox.remove();
        cover.remove();
      }
      let sendButton = document.createElement("button");
      sendButton.id = "send";
      sendButton.innerText = "Send";
      sendButton.onclick = () => {
        let messageObj = {
          type: "message",
          to: "{{ teacherName }}",
          from: "server",
          time: Date.now(),
          content: `{{ username }} requested that ${map.name} by ${map.author} be removed from Tower Defense.<br><b>Reason:</b> ${document.getElementById("reason").value || "none given"}<br><button class="inline popOut" onclick="window.location = '/games/towerdefense'">Go to Tower Defense</button>`
        };
        chatSocket.emit("message", JSON.stringify(messageObj));
        removeBox.remove();
        cover.remove();
      };
      removeBox.append(cancelButton, sendButton);
      document.getElementById("container").append(cover, removeBox);
      document.getElementById("reason").focus();
    }

    function removeMap() {
      gameAlert(`Remove ${map.name} from the game?`, "confirm", "normal", () => {
        request.open("POST", "/tdmapstatus?id=" + map.id + "&status=removed");
        request.send();
        gameAlert("Map removed.");
        document.getElementById("ok").onclick = () => window.location.reload();
      });
    }

    function startGame() {
      //Alerts for maps with errors
      let errorMessage;
      if (!map.start || map.start.length != 2) errorMessage = "No start position given.";
      else if (!map.start.every(pos => Math.abs(pos % 1) == 0.5)) errorMessage = "Invalid start position. Path must start in the middle of a square.";
      else if (!map.lines || !map.lines.length) errorMessage = "No path given.";
      else if (!map.lines.every(line => ["up", "down", "left", "right"].includes(line[0]) && !isNaN(line[1]))) errorMessage = "Invalid path. Use the format [direction, length] for each segment of the path.";
      else if (!Array.isArray(map.waves)) errorMessage = "No waves included.";
      else if (map.waves.length < 75) errorMessage = "Not enough waves. Maps must include 75 waves.";
      else if (map.waves.length > 75) errorMessage = "Too many waves. Maps must include 75 waves.";
      else if (!map.waves.every(wave => Array.isArray(wave))) errorMessage = "Each wave must be contained inside an array.";
      if (errorMessage) {
        gameAlert("<b>Map error:</b> " + errorMessage, "error");
        return;
      }
      
      if (!document.getElementById("lightBackground")) document.getElementById("back")?.remove();
      document.getElementById("prevMap")?.remove();
      document.getElementById("nextMap")?.remove();
      document.getElementById("difficulty")?.remove();
      document.getElementById("startButton")?.remove();
      document.getElementById("lightBackground")?.classList.add("hidden");
      document.getElementById("visual")?.classList.add("hidden");
      document.getElementById("text")?.classList.add("hidden");
      document.getElementById("myMaps")?.remove();
      document.getElementById("mapInfo")?.remove();
      document.getElementById("tryAgain")?.remove();
      document.getElementById("home")?.remove();

      if (!testing) window.onbeforeunload = () => true; //Show warning before leaving page

      //Reset everything
      player.money = 75;
      player.lives = 100;
      player.bonusMoney = 0;
      player.bonusLives = 0;
      gameAchievements = [1, 0, 0, 0, 1, 1, 1];
      enemies = [];
      blinkingCount = 0;
      towers = [];
      grid = Array(15).fill().map(() => Array(32).fill(null));
      frame = 0;
      currentWave = 0;
      currentEnemy = 0;
      superPlane = null;
      resumeGame();
      clearInterval(animate);
      fastForward = false;
      for (let tower in towerTypes) {
        delete towerTypes[tower].power.bought;
        delete towerTypes[tower].power.cooldown;
        document.getElementById(tower)?.remove();
        document.getElementById(tower + "Power")?.remove();
      }

      grid[0][0] = "button";
      if (difficulty == "normal") grid[0][1] = "button";
      grid[0].fill("info", 26, 32); //Area for game info in the top right

      //Make an array with one item for each pixel of the path
      mapArr = [];
      map.lines.forEach(line => {
        for (let i = 0; i < line[1] * 60; i++) mapArr.push(line[0]);
      });

      map.waves.forEach(wave => wave.unshift([8, pause])); //Add a break at the start of each wave

      planePathArr = mapArr.slice(60, -60); //Remove start and end for plane path
      //Make the plane return to the start once it reaches the end
      for (let i = planePathArr.length - 1; i >= 0; i--) {
        switch (planePathArr[i]) {
          case "right":
            planePathArr.push("left");
            break;
          case "left":
            planePathArr.push("right");
            break;
          case "down":
            planePathArr.push("up");
            break;
          case "up":
            planePathArr.push("down");
        }
      }

      superPlanePathArr = [];
      //SuperPlane moves from end to start
      for (let i = mapArr.length - 1; i >= 0; i--) {
        switch (mapArr[i]) {
          case "right":
            superPlanePathArr.push("left");
            break;
          case "left":
            superPlanePathArr.push("right");
            break;
          case "down":
            superPlanePathArr.push("up");
            break;
          case "up":
            superPlanePathArr.push("down");
        }
      }

      if (difficulty == "normal") {
        if (!testing) map.waves.splice(-25, 25); //Remove the last 25 waves
        animate = setInterval(update, 40); //Start the game at normal speed
      } else {
        player.lives = 50;
        fastForward = true;
        animate = setInterval(update, 10); //Start the game at a 4x speed
      }

      //Create the grid
      document.getElementById("grid").classList.remove("hidden")
      let gridHTML = "";
      grid.forEach((row, i) => {
        gridHTML += "<tr>"; //For every array in grid, add a row to the table
        row.forEach((square, j) => gridHTML += `<td id="r${i}c${j}"></td>`); //For every item in the array, add a cell to the row. If the item is not null, set the cell's class to the item's value
        gridHTML += "</tr>";
      });
      document.getElementById("grid").innerHTML = gridHTML;

      //Show the towers
      document.getElementById("towers").classList.remove("hidden");
      for (let tower in towerTypes) {
        document.getElementById("towers").innerHTML += `<img src="../../static/img/towerdefense/${tower}.png" id="${tower}">`;
        document.getElementById("powers").innerHTML += `<button id="${tower}Power" class="invisible">Use power</button>`;
      }
      for (let tower in towerTypes) {
        let towerEl = document.getElementById(tower);
        let powerButton = document.getElementById(tower + "Power");
        let power = towerTypes[tower].power;
        towerEl.onmouseover = () => document.getElementById("towerDesc").innerText = `${towerTypes[tower].name} · $${towerTypes[tower].price} · ${towerTypes[tower].description}`;
        towerEl.onmouseout = () => document.getElementById("towerDesc").innerText = null;
        powerButton.style.color = towerTypes[tower].color;
        powerButton.onmouseover = () => document.getElementById("towerDesc").innerText = power.description;
        powerButton.onmouseout = () => document.getElementById("towerDesc").innerText = null;
        powerButton.onclick = () => {
          if (power.bought && !power.cooldown && towers.find(owned => owned?.name == towerTypes[tower].name) && difficulty == "normal") {
            power.use();
            power.cooldown = 3000;
            power.used = true;
            if (Object.values(towerTypes).every(tower => tower.power.used)) gameAchievements[3] = 1;
          }
        };
      }

      paused = false;
    };

    function pauseGame() {
      paused = true;
      clearInterval(animate);
      document.getElementById("towers").classList.add("hidden");
      //Prevent placing towers while paused
      grid.forEach((row, i) => row.forEach((square, j) => {
        let squareEl = document.getElementById("r" + i + "c" + j);
        if (squareEl.ondragleave) squareEl.ondragleave();
      }));
      for (let tower in towerTypes) if (towerTypes[tower].dragging) document.getElementById(tower).ondragend();
      //If a tower's menu is open, close it
      let menuTower = towers.find(tower => tower?.menuOpen);
      menuTower?.closeMenu();
      document.getElementById("alert")?.remove();
      document.getElementById("controls")?.remove();
      document.getElementById("grid").classList.add("paused");
    }

    function resumeGame() {
      if (paused) {
        animate = setInterval(update, fastForward ? 10 : 40); //If fast forward is turned on, play at 4x the normal speed
        document.getElementById("towers").classList.remove("hidden");
        paused = false;
      }
      document.getElementById("controls")?.remove(); //Hide the controls menu
      document.getElementById("alert")?.remove(); //Hide the alert box
      document.getElementById("alertCover")?.remove();
      document.getElementById("grid").classList.remove("paused");
      document.getElementById("grid").onmouseup = null;
      document.getElementById("grid").onclick = null;
    }

    function gameAlert(message, type = "alert", size = "normal", confirmFunc, promptDefault = "") {
      if (paused === false) pauseGame();
      //If there is already an alert, hide it
      document.getElementById("alert")?.remove();
      document.getElementById("alertCover")?.remove();
      let cover;
      if (!animate) { //Not in a game
        cover = document.createElement("div");
        cover.id = "alertCover";
        document.getElementById("container").append(cover);
      }
      let alertBox = document.createElement("div");
      alertBox.id = "alert";
      alertBox.classList.add("centered");
      if (size == "large") alertBox.classList.add("large");
      if (type == "error") alertBox.classList.add("error");
      let alertText = document.createElement("div");
      alertText.id = "alertText";
      alertText.innerHTML = message.replaceAll("\\\\", "\\");
      alertBox.append(alertText);
      let okButton;
      let yesButton;
      let noButton;
      if (type == "confirm") {
        yesButton = document.createElement("button");
        yesButton.id = "yes";
        yesButton.innerText = "Yes";
        yesButton.onclick = () => {
          resumeGame();
          confirmFunc();
        };
        alertBox.append(yesButton);
        noButton = document.createElement("button");
        noButton.id = "no";
        noButton.innerText = "No";
        noButton.onclick = resumeGame;
        alertBox.append(noButton);
      } else {
        okButton = document.createElement("button");
        okButton.id = "ok";
        okButton.innerText = "OK";
        okButton.onclick = resumeGame;
        alertBox.append(okButton);
      }
      document.getElementById("container").append(alertBox);
      document.addEventListener("keydown", e => {
        if (e.key == "Escape") resumeGame();
      });
      if (type == "prompt") {
        let input = document.createElement("input");
        input.id = "alertInput";
        input.classList.add("box", "hCentered");
        input.value = promptDefault;
        alertText.append(input);
        input.focus();
        input.addEventListener("keydown", () => {
          if (event.key == "Enter") okButton.click();
        });
      } else {
        okButton ? okButton.focus() : yesButton.focus();
      }
    }

    function endGame(complete, exitTest) {
      if (testing) {
        //If a tower's menu is open, close it
        let menuTower = towers.find(tower => tower?.menuOpen);
        menuTower?.closeMenu();
        clearInterval(animate);
        paused = undefined;
        ctx.clearRect(0, 0, 1920, 1080); //Clear the canvas
        document.getElementById("grid").classList.add("hidden");
        document.getElementById("towers").classList.add("hidden");
        if (complete) sound.playSFX("success");
        else if (player.lives == 0)sound.playSFX("shoot");
        ctx.fillStyle = "white";
        ctx.font = "128px Segoe UI";
        ctx.textAlign = "center";
        ctx.fillText(complete ? "Map complete!" : "Game over", 960, 300);
        ctx.font = "48px Segoe UI";
        ctx.fillStyle = "white";
        if (document.getElementById("lightBackground")) {
          ctx.fillText("Click to return to the editor", 960, 800);
          document.getElementById("game").onclick = () => {
            document.getElementById("lightBackground").classList.remove("hidden");
            document.getElementById("visual").classList.remove("hidden");
            document.getElementById("text").classList.remove("hidden");
          };
        } else {
          ctx.fillText("Click to return to the home screen", 960, 800);
          document.getElementById("game").onclick = () => window.location.reload();
        }
        return;
      }

      if (clearCheck) {
        //If a tower's menu is open, close it
        let menuTower = towers.find(tower => tower?.menuOpen);
        document.getElementById("grid").classList.add("hidden");
        document.getElementById("towers").classList.add("hidden");
        menuTower?.closeMenu();
        clearInterval(animate);
        ctx.clearRect(0, 0, 1920, 1080); //Clear the canvas
        window.onbeforeunload = null;
        if (complete) {
          sound.playSFX("success");
          gameAlert("Your map is ready to be published. Do you want to publish it now?", "confirm", "normal", () => {
            request.open("POST", "/tdmapstatus?id=" + map.id + "&status=published");
            request.send();
            gameAlert("Map published.");
            document.getElementById("ok").onclick = () => window.location.reload();
          });
          document.getElementById("no").onclick = () => {
            map.status = "ready";
            request.open("POST", "/tdmapstatus?id=" + map.id + "&status=ready");
            request.send();
            gameAlert("Map saved.");
            document.getElementById("ok").onclick = () => window.location.reload();
          };
        } else {
          sound.playSFX("shoot");
          ctx.fillStyle = "white";
          ctx.font = "128px Segoe UI";
          ctx.textAlign = "center";
          ctx.fillText(complete ? "Map complete!" : "Game over", 960, 300);
          let tryAgain = document.createElement("button");
          tryAgain.id = "tryAgain";
          tryAgain.classList.add("hCentered");
          tryAgain.innerText = "Try again";
          tryAgain.onclick = startGame;
          let home = document.createElement("button");
          home.id = "home";
          home.classList.add("hCentered");
          home.innerText = "Home screen";
          home.onclick = () => window.location.reload();
          document.getElementById("container").append(tryAgain, home);
        }
        return;
      }

      if (complete) {
        sound.playSFX("success");
        let mapNum = map.id || mapIndex;
        let completeNum = (difficulty == "hard") ? "2" : "1";
        if (progress[mapNum] < +completeNum) progress[mapNum] = completeNum; //Update progress
        //Save to the database as a string
        let request1 = new XMLHttpRequest();
        request1.open("POST", "/updateuser?field=tdProgress&value=" + JSON.stringify(progress));
        request1.send();
      } else {
        sound.playSFX("shoot");
        gameAchievements[4] = 0;
        gameAchievements[5] = 0;
        gameAchievements[6] = 0;
      }
      window.onbeforeunload = null;
      let allAchievements = achievements.map((achievement, i) => +achievement || gameAchievements[i]); //New achievements + ones that were earned before
      let request2 = new XMLHttpRequest();
      request2.open("POST", "/updateuser?field=tdAchievements&value=" + allAchievements.join(""));
      request2.send();
      completeMaps = Object.values(progress).filter(char => char != "L").reduce((a, b) => +a + +b);
      completeAchv = achievements.reduce((a, b) => +a + +b);
      let totalComplete = completeMaps + completeAchv;
      if (totalComplete) {
        let request3 = new XMLHttpRequest();
        request3.open("POST", "/savescore?game=towerdefense&score=" + totalComplete);
        request3.send();
      }
      //If a tower's menu is open, close it
      let menuTower = towers.find(tower => tower?.menuOpen);
      menuTower?.closeMenu();
      clearInterval(animate);
      ctx.clearRect(0, 0, 1920, 1080); //Clear the canvas
      document.getElementById("grid").classList.add("hidden");
      document.getElementById("towers").classList.add("hidden");
      ctx.fillStyle = "white";
      ctx.font = "128px Segoe UI";
      ctx.textAlign = "center";
      ctx.fillText(complete ? "Map complete!" : "Game over", 960, 300);
      ctx.font = "64px Segoe UI";
      ctx.fillStyle = "#80ffff";
      ctx.fillText(complete ? `${map.name} cleared on ${difficulty} mode` : `You lost on wave ${currentWave + 1}`, 960, 500);
      ctx.fillStyle = "#ffdf40";
      let newAchievements = achievements.filter((achievement, i) => !+achievement && gameAchievements[i]).length;
      if (newAchievements) ctx.fillText(`${newAchievements} new ${(newAchievements == 1) ? "achievement" : "achievements"} earned`, 960, 600);
      ctx.font = "48px Segoe UI";
      ctx.fillStyle = "white";
      ctx.fillText("Click to return to the home screen", 960, 800);
      document.getElementById("game").onclick = () => window.location.reload();
    }

    function openEditor() {
      let myMaps = allMaps.filter(mapObj => mapObj.author == "{{ username }}" && mapObj.id && mapObj.status != "deleted").sort((a, b) => b.edited - a.edited); //Sort by most recently edited

      ctx.clearRect(0, 0, 1920, 1080); //Clear the canvas
      document.getElementById("lightBackground")?.remove();
      document.getElementById("visual")?.remove();
      document.getElementById("text")?.remove();
      document.getElementById("progress")?.remove();
      document.getElementById("playButton")?.remove();
      document.getElementById("editorButton")?.remove();

      editingMap = undefined;
      newPathSquares = [];
      newPathArr = [];
      newPathStart = undefined;
      newWavesArr = Array(75).fill().map(() => []);
      copiedWave = undefined;

      let back = document.createElement("div");
      back.id = "back";
      back.innerText = "🡄";
      back.onclick = () => window.location.reload();

      ctx.fillStyle = "white";
      ctx.textAlign = "center";
      ctx.font = "56px Segoe UI";
      ctx.fillText("Your maps", 960, 100);

      let myMapsGrid = document.createElement("div");
      myMapsGrid.id = "myMaps";
      myMapsGrid.classList.add("hCentered");
      let newMapWrapper = document.createElement("div");
      newMapWrapper.classList.add("mapWrapper");
      let newMap = document.createElement("div");
      newMap.id = "newMap";
      newMap.innerHTML = "+";
      newMapWrapper.append(newMap, "Create new map");
      newMapWrapper.onclick = createMap;
      myMapsGrid.append(newMapWrapper);
      myMaps.forEach(myMap => {
        let wrapper = document.createElement("div");
        wrapper.id = "map" + myMap.id;
        wrapper.classList.add("mapWrapper");
        let thumbnail = document.createElement("canvas");
        thumbnail.width = 1920;
        thumbnail.height = 1080;
        thumbnail.classList.add("mapThumbnail");
        wrapper.onclick = () => {
          editingMap = myMap;
          editMap();
        }

        let mapName = document.createElement("div");
        mapName.id = "name" + myMap.id;
        mapName.innerText = myMap.name;

        //Draw the thumbnail
        let tctx = thumbnail.getContext("2d");
        tctx.lineWidth = 7.5;
        tctx.strokeStyle = "#80ffff";
        tctx.beginPath();
        let xPos = myMap.start[0] * 60;
        let yPos = myMap.start[1] * 60;
        let col = myMap.start[0] - 0.5;
        let row = myMap.start[1] - 0.5;
        myMap.lines.forEach(line => {
          tctx.moveTo(xPos, yPos);
          for (let i = 0; i < line[1]; i++) {
            switch (line[0]) {
              case "right":
                xPos += 60;
                col++;
                break;
              case "left":
                xPos -= 60;
                col--;
                break;
              case "down":
                yPos += 60;
                row++;
                break;
              case "up":
                yPos -= 60;
                row--;
            }
            tctx.lineTo(xPos, yPos);
          }
        });
        tctx.stroke();

        let lastEdited = document.createElement("div");
        lastEdited.classList.add("lastEdited");
        let editedDate = new Date(myMap.edited);
        let month = editedDate.getMonth() + 1;
        let day = editedDate.getDate();
        let year = editedDate.getFullYear().toString().slice(2);
        let hour = editedDate.getHours();
        let minute = editedDate.getMinutes().toString().padStart(2, "0");
        if (hour > 12) {
          hour -= 12;
          period = "PM";
        } else {
          if (!hour) hour = 12;
          period = "AM";

        }
        lastEdited.innerText = `Edited ${month}/${day}/${year} ${hour}:${minute} ${period}`;
        let statusBox = document.createElement("div");
        statusBox.id = "status" + myMap.id;
        statusBox.classList.add("mapStatus", myMap.status);
        statusBox.innerText = myMap.status;
        if (myMap.status == "ready") statusBox.innerText = "ready to publish";
        if (myMap.status == "removed") statusBox.innerText = "removed by mod";
        wrapper.append(thumbnail, mapName, lastEdited, statusBox);
        myMapsGrid.append(wrapper);
      });
      document.getElementById("container").append(back, myMapsGrid);

      window.onbeforeunload = null;
    }

    function createMap() {
      document.getElementById("mapInfo")?.remove();
      document.getElementById("alertCover")?.remove();
      let cover = document.createElement("div");
      cover.id = "alertCover";
      let mapInfo = document.createElement("div");
      mapInfo.id = "mapInfo";
      mapInfo.classList.add("centered");
      mapInfo.innerHTML = `
        <h2>Create new map</h2><br>
        Map name: <input id="name" class="box" type="text" maxlength="30"><br><br>
        Digipogs to unlock: <input id="digipogs" class="box" type="number" value="0" min="0" max="999">
      `;
      let cancelButton = document.createElement("button");
      cancelButton.id = "cancel";
      cancelButton.innerText = "Cancel";
      cancelButton.onclick = () => {
        mapInfo.remove();
        cover.remove();
      };
      let nextButton = document.createElement("button");
      nextButton.id = "next";
      nextButton.innerText = "Next";
      nextButton.classList.add("unselectable");
      nextButton.onclick = () => {
        if (document.getElementById("name").value.trim()) createPath();
      };
      mapInfo.append(cancelButton, nextButton);
      document.getElementById("container").append(cover, mapInfo);
      document.getElementById("name").oninput = function() {
        if (this.value.trim()) nextButton.classList.remove("unselectable");
        else nextButton.classList.add("unselectable");
      };
      document.getElementById("digipogs").onchange = function() {
        if (this.value < 0) this.value = 0;
        if (this.value > 999) this.value = 999;
        if (!Number.isInteger(this.value)) this.value = Math.floor(this.value);
        this.value = +this.value;
      };
      document.getElementById("name").focus();
    }

    function editMap() {
      document.getElementById("mapInfo")?.remove();
      document.getElementById("alertCover")?.remove();
      let cover = document.createElement("div");
      cover.id = "alertCover";
      let mapInfo = document.createElement("div");
      mapInfo.id = "mapInfo";
      mapInfo.classList.add("centered");
      document.getElementById("container").append(cover, mapInfo);
      if (editingMap.status == "removed") {
        mapInfo.classList.add("removed");
        mapInfo.innerHTML = `
          <h2>Map removed</h2><br>
          This map has been removed by the teacher or a mod.
        `;
        let cancelButton = document.createElement("button");
        cancelButton.id = "cancel";
        cancelButton.innerText = "Back";
        cancelButton.onclick = () => {
          mapInfo.remove();
          cover.remove();
        };
        let deleteButton = document.createElement("button");
        deleteButton.id = "delete";
        deleteButton.innerText = "Remove from map list";
        deleteButton.onclick = () => {
          request.open("POST", "/tdmapstatus?id=" + editingMap.id + "&status=deleted");
          request.send();
          document.getElementById("map" + editingMap.id).remove();
          mapInfo.remove();
          cover.remove();
        };
        mapInfo.append(cancelButton, deleteButton);
        return;
      }
      mapInfo.classList.add("edit");
      mapInfo.innerHTML = `
        <h2>Edit map</h2><br>
        Map name: <input id="name" class="box" type="text" value="${editingMap.name}" maxlength="30"><br><br>
        Digipogs to unlock: <input id="digipogs" class="box" type="number" value="${editingMap.digipogs}" min="0" max="999">
      `;
      let testButton = document.createElement("button");
      testButton.id = "test";
      testButton.innerText = "Test";
      testButton.onclick = testMap;
      let publishButton = document.createElement("button");
      publishButton.id = "publish";
      if (editingMap.status == "published") {
        publishButton.innerText = "Unpublish";
        publishButton.style.fontSize = "110%";
      } else {
        publishButton.innerText = "Publish";
      }
      publishButton.onclick = () => {
        if (editingMap.status == "published") {
          editingMap.status = "ready";
          request.open("POST", "/tdmapstatus?id=" + editingMap.id + "&status=ready");
          request.send();
          publishButton.innerText = "Publish";
          publishButton.style.fontSize = "";
          if (document.getElementById("name").value.trim()) editButton.classList.remove("unselectable");
          document.getElementById("unpublishToEdit").remove();
          let statusBox = document.getElementById("status" + editingMap.id);
          statusBox.classList.remove("published");
          statusBox.classList.add("ready");
          statusBox.innerText = "ready to publish";
        } else {
          mapInfo.remove();
          cover.remove();
          finishMap();
          //If the map couldn't be published, reopen the map info box
          if (document.getElementById("ok") && editingMap.status != "published") document.getElementById("ok").onclick = () => {
            resumeGame();
            editMap();
          }
        }
      };
      let deleteButton = document.createElement("button");
      deleteButton.id = "delete";
      deleteButton.innerText = "Delete";
      deleteButton.onclick = () => {
        let message = (editingMap.status == "published") ? "Unpublish this map and remove it from your maps?" : "Remove this map from your maps?";
        mapInfo.remove();
        gameAlert(message, "confirm", "normal", () => {
          request.open("POST", "/tdmapstatus?id=" + editingMap.id + "&status=deleted");
          request.send();
          document.getElementById("map" + editingMap.id).remove();
          mapInfo.remove();
          cover.remove();
        });
        document.getElementById("no").onclick = () => {
          resumeGame();
          editMap();
        }
      };
      let cancelButton = document.createElement("button");
      cancelButton.id = "cancel";
      cancelButton.innerText = "Cancel";
      cancelButton.onclick = () => {
        mapInfo.remove();
        cover.remove();
      };
      let saveButton = document.createElement("button");
      saveButton.id = "save";
      saveButton.classList.add("unselectable");
      saveButton.innerText = "Save";
      saveButton.onclick = () => {
        let newName = document.getElementById("name").value;
        let newDP = document.getElementById("digipogs").value;
        if (newName.trim() && (newName != editingMap.name || newDP != editingMap.digipogs)) {
          editingMap.name = newName;
          editingMap.digipogs = newDP;
          request.open("POST", "/edittdmap?id=" + editingMap.id + "&map=" + JSON.stringify(editingMap));
          request.send();
          document.getElementById("name" + editingMap.id).innerText = newName;
          mapInfo.remove();
          cover.remove();
        }
      };
      let editButton = document.createElement("button");
      editButton.id = "edit";
      editButton.innerText = "Edit";
      editButton.onclick = () => {
        if (document.getElementById("name").value.trim() && editingMap.status != "published") {
          createPath();
          drawArr();
        }
      };
      if (editingMap.status == "published") {
        editButton.classList.add("unselectable");
        mapInfo.innerHTML += `<div id="unpublishToEdit">You need to unpublish this map before you can edit it.</div>`;
      };
      mapInfo.append(testButton, publishButton, deleteButton, cancelButton, saveButton, editButton);
      document.getElementById("name").oninput = function() {
        if (this.value.trim()) {
          if (editingMap.status != "published") editButton.classList.remove("unselectable");
          if (this.value != editingMap.name) saveButton.classList.remove("unselectable");
          else if (document.getElementById("digipogs").value == editingMap.digipogs) saveButton.classList.add("unselectable");
        } else {
          editButton.classList.add("unselectable");
          if (this.value != editingMap.name) saveButton.classList.add("unselectable");
        }
      };
      document.getElementById("digipogs").oninput = function() {
        if (this.value != editingMap.digipogs) saveButton.classList.remove("unselectable");
        else if (document.getElementById("name").value == editingMap.name) saveButton.classList.add("unselectable");
      }
      document.getElementById("digipogs").onchange = function() {
        if (this.value < 0) this.value = 0;
        if (this.value > 999) this.value = 999;
        if (!Number.isInteger(this.value)) this.value = Math.floor(this.value);
        this.value = +this.value;
        if (this.value != editingMap.digipogs) saveButton.classList.remove("unselectable");
        else if (document.getElementById("name").value == editingMap.name) saveButton.classList.add("unselectable");
      };

      newPathStart = [editingMap.start[1] + 0.5, editingMap.start[0] + 0.5];
      newPathArr = editingMap.lines;
      newWavesArr = editingMap.waves;
    }

    let editingMap;
    let newMapName;
    let newMapDP;
    let newPathSquares = [];
    let newPathArr = [];
    let newPathStart;
    let segmentStart;
    let segmentDirection;
    let segmentIndex = 0;
    let nmctx;
    let drawing;
    let fromStart;

    function createPath(goBack) {
      let lightBg;
      let header;
      let nextButton;
      let visualButton;
      let textButton;
      let nmc;
      let nmg;

      if (goBack == true) {
        lightBg = document.getElementById("lightBackground");
        header = document.getElementById("editorHeader");
        nextButton = document.getElementById("next");
        visualButton = document.getElementById("visual");
        textButton = document.getElementById("text");
        nmc = document.getElementById("newMapCanvas");
        nmg = document.getElementById("newMapGrid");
        document.getElementById("wavesBox").classList.add("hidden");
        document.getElementById("enemiesBox").remove();
        document.getElementById("wavesInstructions").remove();
        document.getElementById("wavesText").classList.add("hidden");
        document.getElementById("exit").remove();
        document.getElementById("test").remove();
        nextButton.style.left = "46%";
        nmc.classList.remove("hidden");
        nmg.classList.remove("hidden");
      } else {
        lightBg = document.createElement("div");
        header = document.createElement("h1");
        nextButton = document.createElement("button");
        visualButton = document.createElement("button");
        textButton = document.createElement("button");
        nmc = document.createElement("canvas");
        nmg = document.createElement("table");
        newMapName = document.getElementById("name").value;
        newMapDP = document.getElementById("digipogs").value;
        document.getElementById("myMaps").remove();
        document.getElementById("mapInfo").remove();
        document.getElementById("alertCover").remove();

        nmc.id = "newMapCanvas";
        nmc.width = 2040;
        nmc.height = 1200;
        nmctx = nmc.getContext("2d");
        resetNMC();
      }

      lightBg.id = "lightBackground";
      lightBg.classList.add("centered");

      let back = document.getElementById("back");
      back.onclick = () => {
        if (checkForChanges()) gameAlert("Exit without saving?", "confirm", "normal", openEditor);
        else openEditor(true);
      };

      header.id = "editorHeader";
      header.classList.add("hCentered");
      header.innerText = "Draw the path";

      nextButton.innerText = "Next";
      nextButton.id = "next";
      nextButton.onclick = () => {
        if (document.getElementById("startText").value && !document.getElementById("pathText").value) return gameAlert("Error: start position provided without path.");
        if (document.getElementById("pathText").value && !document.getElementById("startText").value) return gameAlert("Error: path provided without start position.");
        if (!validatePathText()) return gameAlert("Can't convert your text to a path. Check for errors.");
        if (!newPathArr.length) return gameAlert("Create a path before moving to the next step.");
        if (newWavesArr.every(wave => !wave.length) || JSON.stringify(newWavesArr) == JSON.stringify(wavesDefault)) {
          gameAlert("Do you want to create custom enemy waves for your map? If you select \"No\", the default waves will be used.", "confirm", "normal", createWaves);
          document.getElementById("no").onclick = () => {
            newWavesArr = wavesDefault;
            finishMap();
          }
        } else {
          createWaves();
        }
      };

      visualButton.id = "visual";
      textButton.id = "text";
      visualButton.innerText = "Visual";
      textButton.innerText = "Text";
      visualButton.classList.add("pressed");
      textButton.classList.remove("pressed");
      visualButton.onclick = function() {
        if (this.classList.contains("pressed")) return;
        if (document.getElementById("startText").value && !document.getElementById("pathText").value) return gameAlert("Error: start position provided without path.");
        if (document.getElementById("pathText").value && !document.getElementById("startText").value) return gameAlert("Error: path provided without start position.");
        if (!validatePathText()) return gameAlert("Can't convert your text to a path. Check for errors.");

        document.getElementById("textEditor").classList.add("hidden");
        document.getElementById("newMapCanvas").classList.remove("hidden");
        document.getElementById("newMapGrid").classList.remove("hidden");
        document.getElementById("editorTowers").classList.remove("hidden");
        document.getElementById("pathInstructions").classList.remove("hidden");
        document.getElementById("text").classList.remove("pressed");
        document.getElementById("visual").classList.add("pressed");
        
        if (newPathArr.length) drawArr();
        else resetNMC();
      };
      textButton.onclick = function() {
        if (this.classList.contains("pressed")) return;
        document.getElementById("newMapCanvas").classList.add("hidden");
        document.getElementById("newMapGrid").classList.add("hidden");
        document.getElementById("editorTowers").classList.add("hidden");
        document.getElementById("pathInstructions").classList.add("hidden");
        document.getElementById("textEditor").classList.remove("hidden");
        document.getElementById("visual").classList.remove("pressed");
        document.getElementById("text").classList.add("pressed");
        document.getElementById("pathText").focus();
      };

      nmg.id = "newMapGrid";
      nmg.classList.add("visibleLines");
      let gridHTML = "";
      for (let i = 0; i < 20; i++) {
        gridHTML += "<tr>";
        for (let j = 0; j < 34; j++) gridHTML += `<td id=r${i}c${j} onmousedown="startPath(${i}, ${j});" onmouseover="dragLine(${i}, ${j});"></td>`;
        gridHTML += "</tr>";
      }
      nmg.innerHTML = gridHTML;

      let editorTowers = document.createElement("div");
      editorTowers.id = "editorTowers";

      let instructions = document.createElement("div");
      instructions.id = "pathInstructions";
      instructions.innerHTML = `
        <h3>Instructions:</h3>
        <ul>
          <li>Click on an empty square and drag to start a new path.</li>
          <li>Drag a corner to move it.</li>
          <li>Drag a line to move the entire path.</li>
          <li>Drag outward from the start and end points to extend the path.</li>
          <li>Click and release on an empty square to clear the canvas.</li>
          <li>Switch to the text editor to modify the map as an array.</li>
        </ul>
      `;

      let textEditor = document.createElement("div");
      textEditor.id = "textEditor";
      textEditor.classList.add("hCentered", "hidden");
      textEditor.innerHTML = "Start: "
      let startText = document.createElement("input");
      startText.id = "startText";
      startText.classList.add("box", "light");
      startText.placeholder = "[column, row]";
      textEditor.append(startText);
      textEditor.innerHTML += "<br><br>Path: <br>"
      let pathText = document.createElement("textarea");
      pathText.id = "pathText";
      pathText.classList.add("light");
      pathText.placeholder = "[direction, length],\n[direction, length],";
      textEditor.append(pathText);
      
      lightBg.append(back, header, nextButton, nmc, nmg, editorTowers, instructions, textEditor);
      document.getElementById("container").append(lightBg, visualButton, textButton);
    }

    function resetNMC() {
      nmctx.clearRect(0, 0, 2040, 1200);
      nmctx.drawImage(images.buttons.menu, 75, 75, 30, 30);
      images.buttons.menu.onload = () => nmctx.drawImage(images.buttons.menu, 75, 75, 30, 30); //It sometimes fails to draw the image the first time, so try again when the image is loaded
      nmctx.drawImage(images.buttons.fastForwardWhite, 135, 75, 30, 30);
      images.buttons.fastForwardWhite.onload = () => nmctx.drawImage(images.buttons.fastForwardWhite, 135, 75, 30, 30);
      nmctx.font = "30px monospace";
      nmctx.fillStyle = "#ddd";
      nmctx.fillText("00/50", 1624, 100);
      nmctx.fillStyle = "#80ff80";
      nmctx.fillText("$00075", 1744, 100);
      nmctx.fillStyle = "#ff6860";
      nmctx.fillText("❤︎100", 1880, 100);
      for (let i = 0; i < 20; i++) for (let j = 0; j < 34; j++) {
        let square = document.getElementById(`r${i}c${j}`);
        if (square) {
          square.classList.remove("line", "corner", "endpoint");
          square.onmousedown = () => startPath(i, j);
        }
      }
      nmctx.lineWidth = 1.5;
      nmctx.strokeStyle = "#80ffff";
      nmctx.fillStyle = "#80ffff";

      window.onbeforeunload = () => checkForChanges() || null;
    }

    function startPath(row, col) {
      resetNMC();

      newPathArr = [];
      newPathStart = [row, col];
      segmentStart = newPathStart;
      segmentDirection = null;
      segmentIndex = 0;
      newPathSquares = [newPathStart];
      drawing = true;
      fromStart = false;
      
      nmctx.beginPath();
      nmctx.arc(col * 60 + 30, row * 60 + 30, 15, 0, 2 * Math.PI); //Draw a large circle at the start
      nmctx.fill();
      let square = document.getElementById(`r${row}c${col}`);
      if (square) {
        square.classList.remove("line", "corner");
        square.classList.add("endpoint");
        square.onmousedown = () => continuePath(row, col, true);
      }

      nmctx.beginPath();
      nmctx.moveTo(col * 60 + 30, row * 60 + 30);

      document.body.onmouseup = () => endPath(row, col);
    }

    function dragLine(row, col) {
      if (!drawing) return;

      let lastSquare = newPathSquares.at(-1);
      newPathSquares.push([row, col]);
      let lastDirection = segmentDirection;
      if (row == lastSquare[0] && col == lastSquare[1]) {
        //If the square is the same, don't change the direction
      } else if (row == lastSquare[0]) {
        if (col > lastSquare[1]) segmentDirection = "right";
        else segmentDirection = "left";
      } else if (col == lastSquare[1]) {
        if (row > lastSquare[0]) segmentDirection = "down";
        else segmentDirection = "up";
      } else {
        //Don't allow diagonal lines
        newPathSquares.pop();
        return;
      }
      if (lastDirection && segmentDirection != lastDirection) newSegment(...lastSquare, lastDirection);
      nmctx.lineTo(col * 60 + 30, row * 60 + 30);
      nmctx.stroke();
      nmctx.stroke(); //Stroke twice, because only doing it once makes the last line darker for some reason

      let square = document.getElementById(`r${row}c${col}`);
      if (square && !square.classList.contains("corner") && !square.classList.contains("endpoint")) {
        square.classList.add("line");
        square.onmousedown = () => movePath(row, col);
      }

      document.body.onmouseup = () => endPath(row, col);
    }

    function newSegment(row, col, direction) {
      let length;
      switch (direction) {
        case "left":
        case "right":
          length = Math.abs(col - segmentStart[1]);
          break;
        case "up":
        case "down":
          length = Math.abs(row - segmentStart[0]);
      }
      if (!length && !fromStart) return;
      if (fromStart) {
        let opposites = [["left", "right"], ["up", "down"]];
        let opposite;
        if (fromStart) opposite = opposites.find(arr => arr.includes(direction)).find(item => item != direction);
        //Extend the first segment and change the starting point
        if (length) newPathArr.unshift([opposite, length]);
        newPathStart = [row, col];
      } else {
        newPathArr.push([direction, length]);
      }
      segmentStart = [row, col];
      
      nmctx.beginPath();
      nmctx.arc(col * 60 + 30, row * 60 + 30, 7.5, 0, 2 * Math.PI); //Draw a small circle at the corner
      nmctx.fill();
      nmctx.moveTo(col * 60 + 30, row * 60 + 30);
      let square = document.getElementById(`r${row}c${col}`);
      if (square && !square.classList.contains("endpoint")) {
        square.classList.add("corner");
        let i = segmentIndex;
        square.onmousedown = () => moveCorner(row, col, i);
      }
      segmentIndex++;
    }

    function drawArr(noEnd) {
      let arr = newPathArr;
      let row = newPathStart[0];
      let col = newPathStart[1];
      startPath(row, col);
      arr.forEach(segment => {
        for (let i = 0; i < segment[1]; i++) {
          if (segment[0] == "right") col += 1;
          else if (segment[0] == "left") col -= 1;
          else if (segment[0] == "down") row += 1;
          else if (segment[0] == "up") row -= 1;
          dragLine(row, col);
        }
      });
      if (!noEnd) endPath(row, col);
    }

    function endPath(row, col) {
      newSegment(row, col, segmentDirection);
      nmctx.fillRect(col * 60 + 15, row * 60 + 15, 30, 30); //Draw a square at the end
      let square = document.getElementById(`r${row}c${col}`);
      if (square) {
        square.classList.remove("line", "corner");
        square.classList.add("endpoint");
        square.onmousedown = () => continuePath(row, col);
      }
      let newPathStr = "";
      if (newPathArr.every(segment => segment[1])) newPathStr = newPathArr.map(segment => `["${segment[0]}", ${segment[1]}],\n`).join("");
      if (newPathStr) {
        document.getElementById("startText").value = `[${newPathStart[0] - 1}, ${newPathStart[1] - 1}]`;
      } else {
        resetNMC();
        document.getElementById("startText").value = null;
      }
      document.getElementById("pathText").value = newPathStr;
      drawing = false;
      document.body.onmouseup = null;
    }

    function moveCorner(row, col, index) {
      let oldLengths = newPathArr.map(segment => segment[1]);
      let oldStartPos = [...newPathStart];
      let oldPathLength = newPathArr.length;
      for (let i = 0; i < 20; i++) {
        for (let j = 0; j < 34; j++) document.getElementById(`r${i}c${j}`).onmouseover = function() {
          let action1;
          let action2;
          let axis1;
          let axis2;
          switch (newPathArr[index][0]) {
            case "left":
              axis1 = "x";
              if (j < col) action1 = "stretch";
              if (j > col) action1 = "shrink";
              break;
            case "right":
              axis1 = "x";
              if (j > col) action1 = "stretch";
              if (j < col) action1 = "shrink";
              break;
            case "up":
              axis1 = "y";
              if (i < row) action1 = "stretch";
              if (i > row) action1 = "shrink";
              break;
            case "down":
              axis1 = "y";
              if (i > row) action1 = "stretch";
              if (i < row) action1 = "shrink";
          }
          switch (newPathArr[index + 1]?.[0]) {
            case "left":
              axis2 = "x";
              if (j > col) action2 = "stretch";
              if (j < col) action2 = "shrink";
              break;
            case "right":
              axis2 = "x";
              if (j < col) action2 = "stretch";
              if (j > col) action2 = "shrink";
              break;
            case "up":
              axis2 = "y";
              if (i > row) action2 = "stretch";
              if (i < row) action2 = "shrink";
              break;
            case "down":
              axis2 = "y";
              if (i < row) action2 = "stretch";
              if (i > row) action2 = "shrink";
          }
          
          function resizeSegment(segment, action, axis) {
            let direction = newPathArr[segment][0];
            let oldLength = oldLengths[segment];
            let sameAxis = (axis == "x") ? ["left", "right"] : ["up", "down"];
            let parallel;
            if (segment == index) parallel = newPathArr.indexOf(newPathArr.slice(segment + 2).find(item => sameAxis.includes(item[0])));
            else parallel = newPathArr.indexOf(newPathArr.slice(0, segment - 1).reverse().find(item => sameAxis.includes(item[0])));
            let parallelDirection = newPathArr[parallel]?.[0];
            let parallelOldLength = oldLengths[parallel];
            let otherDirection = (segment == index) ? newPathArr[segment + 1][0] : newPathArr[segment - 1][0]; //The direction of the other segment that shares the same corner
            let difference = Math.abs((axis == "x") ? col - j : row - i);
            let sign = (action == "stretch") ? 1 : -1;
            if (action) {
              newPathArr[segment][1] = oldLength + difference * sign;
              if (newPathArr[parallel] && !sameAxis.includes(otherDirection)) {
                //When stretching or shrinking a segment, also change a nearby segment's length so the rest of the path doesn't move
                if (direction == parallelDirection) newPathArr[parallel][1] = parallelOldLength - difference * sign;
                else if (sameAxis.includes(parallelDirection)) newPathArr[parallel][1] = parallelOldLength + difference * sign;
              }
              let noneSameAxis = newPathArr.slice(0, segment - 1).every(item => !sameAxis.includes(item[0])); //Check if all previous segments are on the opposite axis from the current one
              //If this is the second segment and there is no parallel segment to resize, change the start position
              if (segment == index + 1 && ((!newPathArr[parallel] && !sameAxis.includes(otherDirection)) || (!sameAxis.includes(otherDirection) && noneSameAxis))) {
                if (direction == "left") newPathStart[1] = oldStartPos[1] + difference * sign;
                else if (direction == "right") newPathStart[1] = oldStartPos[1] - difference * sign;
                else if (direction == "up") newPathStart[0] = oldStartPos[0] + difference * sign;
                else if (direction == "down") newPathStart[0] = oldStartPos[0] - difference * sign;
              }
            } else {
              newPathArr[segment][1] = oldLength;
              if (parallelOldLength) newPathArr[parallel][1] = parallelOldLength;
              if (segment == index + 1) newPathStart = oldStartPos;
            }
          }
          resizeSegment(index, action1, axis1); //The segment that ends at this corner
          resizeSegment(index + 1, action2, axis2); //The segment that starts at this corner
          drawArr();
          //If two segments have been combined and the square is still a corner, trigger the mousedown event to continue dragging 
          if (newPathArr.length < oldPathLength) {
            if (this.classList.contains("corner")) this.onmousedown();
            else resetDragFunc();
          }
          document.body.onmouseup = resetDragFunc;
        };
      }
      document.body.onmouseup = resetDragFunc;
    }

    function movePath(row, col) {
      document.getElementById("newMapGrid").classList.add("draggingLine");
      let oldStartPos = [...newPathStart];
      for (let i = 0; i < 20; i++) {
        for (let j = 0; j < 34; j++) document.getElementById(`r${i}c${j}`).onmouseover = () => {
          newPathStart[0] = oldStartPos[0] + i - row;
          newPathStart[1] = oldStartPos[1] + j - col;
          drawArr();
          document.body.onmouseup = () => {
            document.getElementById("newMapGrid").classList.remove("draggingLine");
            resetDragFunc();
          }
        };
      }
      document.body.onmouseup = () => {
        document.getElementById("newMapGrid").classList.remove("draggingLine");
        resetDragFunc();
      }
    }

    function continuePath(row, col, start) {
      let dragInward;
      let oldLengths = newPathArr.map(segment => segment[1]);
      let oldStartPos = [...newPathStart];
      let firstDrag = true;
      drawArr();
      drawing = true;
      for (let i = 0; i < 20; i++) for (let j = 0; j < 34; j++) document.getElementById(`r${i}c${j}`).onmouseover = () => {
        if (dragInward === undefined) {
          //Check if the first/last segment is being shortened
          let firstDirection = newPathArr[0][0];
          let finalDirection = newPathArr.at(-1)[0];
          if (!start && ((finalDirection == "left" && j > col) || (finalDirection == "right" && j < col) || (finalDirection == "up" && i > row) || (finalDirection == "down" && i < row))) dragInward = true;
          else if (start && ((firstDirection == "left" && j < col) || (firstDirection == "right" && j > col) || (firstDirection == "up" && i < row) || (firstDirection == "down" && i > row))) dragInward = true;
          else dragInward = false;
        }
        if (dragInward) {
          let squareClasses = document.getElementById(`r${i}c${j}`).classList;
          if ((!squareClasses.contains("line") && !squareClasses.contains("endpoint")) || (newPathArr.length == 1 && newPathArr[0][1] == 1)) { //Don't do anything if not dragging along the path or the path is at its minimum length
            drawing = false;
            resetDragFunc();
            return;
          }
          //Instead of adding a new segment, shorten this one
          let segment = start ? 0 : newPathArr.length - 1;
          let direction = newPathArr[segment][0];
          let oldLength = oldLengths[segment];
          let difference = Math.abs((direction == "left" || direction == "right") ? col - j : row - i);
          if (!difference) dragInward = undefined;
          newPathArr[segment][1] = oldLength - difference;
          if (start) {
            if (direction == "left") newPathStart[1] = oldStartPos[1] - difference;
            else if (direction == "right") newPathStart[1] = oldStartPos[1] + difference;
            else if (direction == "up") newPathStart[0] = oldStartPos[0] - difference;
            else if (direction == "down") newPathStart[0] = oldStartPos[0] + difference;
          }
          drawArr();
          document.body.onmouseup = resetDragFunc;
          if (difference == oldLength) { //Reset when the first/last segment is completely removed
            resetDragFunc();
            continuePath(i, j, start);
          }
          return;
        }
        let lastSquare = newPathSquares.at(-1);
        if (start) drawing = true;
        else drawArr(true);
        fromStart = start;
        if (fromStart && firstDrag) {
          let opposites = [["left", "right"], ["up", "down"]];
          segmentDirection = opposites.find(opposite => opposite.includes(newPathArr[0][0])).find(direction => direction != newPathArr[0][0]); //Get the reverse of the first segment's direction; this allows new segments to be added to the start
          newPathSquares.push(newPathStart);
          nmctx.clearRect(newPathStart[1] * 60, newPathStart[0] * 60, 60, 60); //Remove the circle at the start
          //Draw a line in the gap
          nmctx.moveTo(newPathSquares[1][1] * 60 + 30, newPathSquares[1][0] * 60 + 30);
          nmctx.lineTo(newPathStart[1] * 60 + 30, newPathStart[0] * 60 + 30);
          nmctx.stroke();
          nmctx.stroke();
        }
        if (fromStart) {
          segmentStart = [...newPathStart];
          if (!firstDrag) newPathSquares.push(lastSquare);
          nmctx.moveTo(newPathStart[1] * 60 + 30, newPathStart[0] * 60 + 30);
        } else {
          dragLine(...lastSquare);
        }
        dragLine(i, j);
        firstDrag = false;
        document.body.onmouseup = () => {
          endPath(i, j);
          drawArr();
          resetDragFunc();
        };
      };
      document.body.onmouseup = () => {
        drawing = false;
        resetDragFunc();
      };
    }

    function resetDragFunc() {
      for (let i = 0; i < 20; i++) for (let j = 0; j < 34; j++) document.getElementById(`r${i}c${j}`).onmouseover = () => dragLine(i, j);
    }

    function validatePathText() {
      let startStr = document.getElementById("startText").value;
      if (startStr.length && (!startStr.startsWith("[") || !startStr.endsWith("]"))) return;
      let start = startStr.replaceAll(" ", "").slice(1, -1).split(",");
      if (startStr && start.length == 2 && start.every(pos => Number.isInteger(+pos))) newPathStart = start.map(pos => +pos + 1);
      else if (startStr) return;
      let str = document.getElementById("pathText").value.replaceAll("\n", "").replaceAll(" ", "");
      let strQuotes = str.split("").filter(char => char == "\"" || char == "'");
      //Check for mismatched quotation marks
      strQuotes.forEach((char, i) => {
        if (i % 2 && char != strQuotes[i - 1]) return;
      });
      str = str.replaceAll("'", "\"");
      ["up", "down", "left", "right"].forEach(direction => str = str.replaceAll(`[${direction},`, `["${direction}",`)); //Add quotes around directions
      if (str.at(-1) == ",") str = str.slice(0, -1);
      let newPathJSON = "[" + str + "]";
      try {
        newPathArr = JSON.parse(newPathJSON);
      } catch {
        return;
      }
      newPathArr = newPathArr.map(segment => [segment[0], +segment[1]]);

      return newPathArr.every(segment =>
        Array.isArray(segment)
        && segment.length == 2
        && ["up", "down", "left", "right"].includes(segment[0])
        && Number.isInteger(segment[1])
        && segment[1] > 0
      );
    }

    let newWavesArr = Array(75).fill().map(() => []);
    let movingWave;
    let startingPosition;
    let waveDisplacement;
    let cursorY;
    let copiedWave;
    let pauseImg = new Image();
    pauseImg.src = "../../static/img/towerdefense/break.png";
    let alertImg = new Image();
    alertImg.src = "../../static/img/towerdefense/alert.png";

    function createWaves() {
      let container = document.getElementById("container");

      document.getElementById("newMapCanvas").classList.add("hidden");
      document.getElementById("newMapGrid").classList.add("hidden");
      document.getElementById("editorTowers").remove();
      document.getElementById("pathInstructions").remove();
      document.getElementById("textEditor").classList.add("hidden");
      document.getElementById("editorHeader").innerText = "Create enemy waves";

      let back = document.getElementById("back");
      back.onclick = () => createPath(true);
      
      document.getElementById("visual").classList.add("pressed");
      document.getElementById("visual").onclick = function() {
        if (this.classList.contains("pressed")) return;
        if (!validateWavesText()) return gameAlert("Can't convert your text to waves. Check for errors.");
        let errorAlert = wftError();
        if (errorAlert) return gameAlert("Error: " + errorAlert);

        document.getElementById("wavesInstructions").classList.add("hidden");
        document.getElementById("wavesText").classList.add("hidden");
        document.getElementById("wavesBox").classList.remove("hidden");
        document.getElementById("enemiesBox").classList.remove("hidden");
        document.getElementById("text").classList.remove("pressed");
        document.getElementById("visual").classList.add("pressed");
        
        fillWaves();
      };
      document.getElementById("text").classList.remove("pressed");
      document.getElementById("text").onclick = function() {
        if (this.classList.contains("pressed")) return;
        updateWavesText();
        document.getElementById("wavesBox").classList.add("hidden");
        document.getElementById("enemiesBox").classList.add("hidden");
        document.getElementById("wavesInstructions").classList.remove("hidden");
        document.getElementById("wavesText").classList.remove("hidden");
        document.getElementById("visual").classList.remove("pressed");
        document.getElementById("text").classList.add("pressed");
        document.getElementById("pathText").focus();
      };

      let wavesBox;
      if (document.getElementById("wavesBox")) {
        document.getElementById("wavesBox").classList.remove("hidden");
      } else {
        wavesBox = document.createElement("div");
        wavesBox.id = "wavesBox";
        let lastMovement = 0;
        wavesBox.oncontextmenu = function() {
          event.preventDefault();
          document.getElementById("contextMenu")?.remove();
          let menu = document.createElement("div");
          menu.id = "contextMenu";
          menu.style.left = event.clientX - container.getBoundingClientRect().x + "px";
          menu.style.top = event.clientY - container.getBoundingClientRect().y + "px";
          let clearAll = document.createElement("div");
          clearAll.innerText = "Clear all waves";
          if (!newWavesArr.some(wave => wave.length)) clearAll.classList.add("unselectable");
          clearAll.onmousedown = () => event.stopPropagation();
          clearAll.onclick = () => {
            if (!newWavesArr.some(wave => wave.length)) return;
            clearAllFunc();
            menu.remove();
          };
          let loadDefault = document.createElement("div");
          loadDefault.innerText = "Load default waves";
          loadDefault.onmousedown = () => event.stopPropagation();
          loadDefault.onclick = () => {
            loadDefaultFunc();
            menu.remove();
          };
          menu.append(clearAll, loadDefault);
          container.append(menu);
        };
        document.onmousedown = () => document.getElementById("contextMenu")?.remove();
        window.onresize = () => document.getElementById("contextMenu")?.remove();
        wavesBox.onmousemove = function() {
          if (movingWave == null) return;
          if (Date.now() - lastMovement < 30) return; //Only update every 30ms to reduce lag
          lastMovement = Date.now();

          event.clientY ??= cursorY; //Set the cursor position when this is triggered by a scroll event

          for (let i = 0; i < 75; i++) {
            let thisWaveEl = document.getElementById("wave" + i);
            movingEl = document.getElementById("wave" + movingWave);
            let yCenter = thisWaveEl.getBoundingClientRect().y + thisWaveEl.getBoundingClientRect().height / 2; //The vertical center of the wave element
            movingEl.style.zIndex = 9999; //Put the wave being moved in the front
            waveDisplacement += event.clientY + this.scrollTop - waveDisplacement - startingPosition; //Calculate how much the wave has moved since the last event
            movingEl.style.top = waveDisplacement + "px";
            if ((event.clientY > yCenter && i > movingWave) || (event.clientY < yCenter && i < movingWave)) { //Wave moved before or after another
              //Switch contents of waves
              let movingArr = JSON.parse(JSON.stringify(newWavesArr[movingWave]));
              let thisArr = JSON.parse(JSON.stringify(newWavesArr[i]));
              clearWaveFunc(movingEl);
              clearWaveFunc(thisWaveEl);
              pasteContentsFunc(i, movingArr);
              pasteContentsFunc(movingWave, thisArr);
              startingPosition += thisWaveEl.getBoundingClientRect().y - movingEl.getBoundingClientRect().y + waveDisplacement; //Calculate the difference in the waves' original positions
              movingEl.style.top = 0; //Reset the wave's position when it's no longer being moved
              movingEl.style.zIndex = "";
              waveDisplacement += event.clientY + this.scrollTop - waveDisplacement - startingPosition
              thisWaveEl.style.top = waveDisplacement + "px";
              movingWave = i;
            }
          }
          cursorY = event.clientY;
        };
        wavesBox.onscroll = wavesBox.onmousemove; //Update the positions of waves when wavesBox is scrolled
        document.onmouseup = () => {
          if (movingWave == null) return;
          document.getElementById("wave" + movingWave).style.top = 0;
          document.getElementById("wave" + movingWave).style.zIndex = "";
          wavesBox.classList.remove("movingWave");
          movingWave = null;
        }
        for (let i = 0; i < 75; i++) {
          if (i == 50) {
            let hmo = document.createElement("h1");
            hmo.id = "hardModeOnly";
            hmo.innerText = "Hard mode only"
            wavesBox.append(hmo);
          }
          let waveEl = document.createElement("div");
          waveEl.id = "wave" + i;
          waveEl.classList.add("wave");
          waveEl.ondragenter = function() {
            if (!draggingEnemy) return;

            let outline = document.createElement("div");
            outline.id = "enemyOutline";
            outline.classList.add("waveEnemy");
            if (draggingEnemy.boss) outline.classList.add("boss");
            if (draggingEnemy.code == "repeat") outline.classList.add("waveRepeat");
            this.append(outline);
          };
          waveEl.ondragover = function() {
            if (!draggingEnemy) return;
            
            event.preventDefault();
            this.classList.add("dragTarget");
            if (!document.getElementById("enemyOutline")) this.ondragenter(); //Outline sometimes fails to appear on dragenter
            draggingPosition = this.children.length - 1;
            let waveNumLine = this.children[0].getBoundingClientRect().x + this.children[0].getBoundingClientRect().width;
            if (event.clientX < waveNumLine) { //Dragging over waveNumber
              Array.from(this.children).forEach(child => child.style.order = 0); //Move the item being dragged to the end
            } else {
              Array.from(this.children).forEach((child, i) => {
                let xCenter = child.getBoundingClientRect().x + child.getBoundingClientRect().width / 2;
                child.style.order = (event.clientX < xCenter && !child.id && !child.classList.contains("waveNumber")) ? 1 : 0; //Excluding elements with ids so the order of #enemyOutline is always 0
                if (event.clientX > xCenter && !child.id) draggingPosition = i; //Make draggingPosition equal to the number of wave items to the left of #enemyOutline
              });
            }
          };
          waveEl.ondragleave = function() {
            this.classList.remove("dragTarget");
            document.getElementById("enemyOutline")?.remove();
            Array.from(this.children).forEach(child => child.style.order = 0); //Reset order of elements
          };
          waveEl.ondrop = function() {
            this.classList.remove("dragTarget");
            addEnemy(draggingEnemy, draggingAbility, i, draggingPosition);
            Array.from(this.children).forEach(child => child.style.order = 0); //Reset order of elements
          };
          waveEl.oncontextmenu = function() {
            event.preventDefault();
            event.stopPropagation();
            document.getElementById("contextMenu")?.remove();
            let menu = document.createElement("div");
            menu.id = "contextMenu";
            menu.style.left = event.clientX - container.getBoundingClientRect().x + "px";
            menu.style.top = event.clientY - container.getBoundingClientRect().y + "px";
            let clearWave = document.createElement("div");
            clearWave.innerText = "Clear wave";
            if (!newWavesArr[i].length) clearWave.classList.add("unselectable");
            clearWave.onmousedown = () => event.stopPropagation();
            clearWave.onclick = () => {
              if (!newWavesArr[i].length) return;
              clearWaveFunc(this);
              menu.remove();
            };
            let copyContents = document.createElement("div");
            copyContents.innerText = "Copy contents";
            if (!newWavesArr[i].length) copyContents.classList.add("unselectable");
            copyContents.onmousedown = () => event.stopPropagation();
            copyContents.onclick = () => {
              if (!newWavesArr[i].length) return;
              copiedWave = JSON.parse(JSON.stringify(newWavesArr[i]));
              menu.remove();
            };
            let pasteContents = document.createElement("div");
            pasteContents.innerText = "Paste contents";
            if (!copiedWave) pasteContents.classList.add("unselectable");
            pasteContents.onmousedown = () => event.stopPropagation();
            pasteContents.onclick = () => {
              if (!copiedWave) return;
              pasteContentsFunc(i, copiedWave);
              menu.remove();
            };
            let clearAll = document.createElement("div");
            clearAll.innerText = "Clear all waves";
            if (!newWavesArr.some(wave => wave.length)) clearAll.classList.add("unselectable");
            clearAll.onmousedown = () => event.stopPropagation();
            clearAll.onclick = () => {
              if (!newWavesArr.some(wave => wave.length)) return;
              clearAllFunc();
              menu.remove();
            };
            let loadDefault = document.createElement("div");
            loadDefault.innerText = "Load default waves";
            loadDefault.onmousedown = () => event.stopPropagation();
            loadDefault.onclick = () => {
              loadDefaultFunc();
              menu.remove();
            };
            menu.append(clearWave, copyContents, pasteContents, clearAll, loadDefault);
            container.append(menu);
          };
          let waveNum = document.createElement("div");
          waveNum.classList.add("waveNumber");
          waveNum.innerText = i + 1;
          waveNum.onmousedown = function() {
            if (event.buttons != 1) return; //Only drag the wave is the left mouse button is down
            movingWave = +this.innerText - 1;
            startingPosition = event.clientY + wavesBox.scrollTop;
            waveDisplacement = 0; //This is the wave's vertical distance from its original position
            cursorY = event.clientY;
            wavesBox.classList.add("movingWave");
          };
          waveEl.append(waveNum);
          wavesBox.append(waveEl);
        }
        let removeItem = document.createElement("div");
        removeItem.id = "removeItem";
        removeItem.classList.add("hCentered", "hidden");
        removeItem.innerText = "Remove";
        removeItem.ondragenter = function() {
          this.classList.add("dragOver");
        }
        removeItem.ondragover = () => event.preventDefault();
        removeItem.ondragleave = function() {
          this.classList.remove("dragOver");
        };
        removeItem.ondrop = function() {
          this.classList.remove("dragOver");
        };
        wavesBox.append(removeItem);

        function clearWaveFunc(el) {
          Array.from(el.children).forEach(child => {
            if (child.classList.contains("waveEnemy")) {
              child.ondragstart();
              child.ondrag();
              child.ondragend();
            }
          });
        }

        function pasteContentsFunc(wave, contents) {
          contents.forEach(item => {
            if (item == "pause") addEnemy({code: "pause", img: pauseImg}, null, wave, newWavesArr[wave].length);
            else if (item[0] == "alert") addEnemy({code: "alert", img: alertImg, arr: item}, null, wave, newWavesArr[wave].length);
            else if (Array.isArray(item)) addEnemy({code: "repeat", arr: item}, null, wave, newWavesArr[wave].length);
            else for (let type in enemyTypes) if (item[0] == enemyTypes[type].code) addEnemy(enemyTypes[type], item[1], wave, newWavesArr[wave].length);
          });
        }

        function clearAllFunc() {
          gameAlert("Remove the contents of all waves?", "confirm", "normal", () => {
            Array.from(wavesBox.children).forEach(wave => Array.from(wave.children).forEach(child => {
              if (child.classList.contains("waveEnemy")) {
                child.ondragstart();
                child.ondrag();
                child.ondragend();
              }
            }));
          });
        }

        function loadDefaultFunc() {
          if (newWavesArr.some(wave => wave.length)) {
            gameAlert("Remove the contents of all waves and replace them with the default waves?", "confirm", "normal", () => {
              Array.from(wavesBox.children).forEach(wave => Array.from(wave.children).forEach(child => {
                if (child.classList.contains("waveEnemy")) {
                  child.ondragstart();
                  child.ondrag();
                  child.ondragend();
                }
              }));
              newWavesArr = JSON.parse(JSON.stringify(wavesDefault).replaceAll("[10,null]", "\"pause\""));
              updateWavesText();
              validateWavesText();
              fillWaves();
            });
          } else {
            newWavesArr = JSON.parse(JSON.stringify(wavesDefault).replaceAll("[10,null]", "\"pause\""));
            updateWavesText();
            validateWavesText();
            fillWaves();
          }
        }
      }

      let enemiesBox = document.createElement("div");
      enemiesBox.id = "enemiesBox";

      let enemiesHeader = document.createElement("h1");
      enemiesHeader.innerText = "Enemies";
      enemiesHeader.style.width = "100%";
      enemiesBox.append(enemiesHeader);
      let ability = document.createElement("div");
      ability.id = "ability";
      ability.innerText = "Ability: ";
      let abilityDropdown = document.createElement("select");
      abilityDropdown.id = "abilityDropdown";
      abilityDropdown.innerHTML = `
        <option value="">Normal</option>
        <option value="h">Healing</option>
        <option value="a">Acceleration</option>
        <option value="s">Split</option>
        <option value="k">Blink</option>
        <option value="d">Shield</option>
      `;
      abilityDropdown.onchange = function() {
        draggingAbility = this.value;
        for (let type in enemyTypes) {
          let wrapperEl = document.getElementById(type);
          let imgEl = document.getElementById(type + "Img");
          let abilityEl = document.getElementById(type + "Ability");
          imgEl.src = enemyTypes[type].img.src; //Reset to normal images
          wrapperEl.classList.remove("unselectable");
          imgEl.draggable = true;
          wrapperEl.classList.remove("blink");
          abilityEl.src = "";
          switch (this.value) {
            case "h":
              abilityEl.src = images.abilitySymbols.healing.src;
              break;
            case "a":
              abilityEl.src = images.abilitySymbols.acceleration.src;
              break;
            case "s":
              if (enemyTypes[type].imgSplit) imgEl.src = enemyTypes[type].imgSplit.src;
              else {
                wrapperEl.classList.add("unselectable");
                imgEl.draggable = false;
              }
              break;
            case "k":
              wrapperEl.classList.add("blink");
              wrapperEl.getAnimations()[0].startTime = 0;
              break;
            case "d":
              abilityEl.src = images.abilitySymbols.shield.src;
          }
        }
      };
      ability.append(abilityDropdown);
      enemiesBox.append(ability);
      draggingAbility = "";
      for (let type in enemyTypes) {
        let wrapper = document.createElement("div");
        wrapper.id = type;
        wrapper.classList.add("enemy");
        if (enemyTypes[type].boss) wrapper.classList.add("boss");
        let img = new Image();
        img.src = enemyTypes[type].img.src;
        img.id = type + "Img";
        img.classList.add("enemyImg");
        img.ondragstart = () => draggingEnemy = enemyTypes[type];
        img.ondragend = () => draggingEnemy = null;
        wrapper.append(img);
        wrapper.title = enemyTypes[type].name;
        let abilitySymbol = new Image();
        abilitySymbol.id = type + "Ability";
        abilitySymbol.classList.add("abilitySymbol", "centered");
        wrapper.append(abilitySymbol);
        enemiesBox.append(wrapper);
      }

      let pauseHeader = document.createElement("h1");
      pauseHeader.innerText = "Pause";
      pauseHeader.style.width = "30%";
      pauseHeader.style.marginLeft = "10%";

      let alertHeader = document.createElement("h1");
      alertHeader.innerText = "Alert";
      alertHeader.style.width = "30%";
      alertHeader.style.marginRight = "10%";

      let pauseWrapper = document.createElement("div");
      pauseWrapper.classList.add("enemy");
      pauseImg.ondragstart = () => draggingEnemy = {
        code: "pause",
        img: pauseImg
      };
      pauseImg.ondragend = () => draggingEnemy = null;
      pauseWrapper.append(pauseImg);

      let alertWrapper = document.createElement("div");
      alertWrapper.classList.add("enemy");
      alertImg.ondragstart = () => draggingEnemy = {
        code: "alert",
        img: alertImg
      };
      alertImg.ondragend = () => draggingEnemy = null;
      alertWrapper.append(alertImg);

      let repeatHeader = document.createElement("h1");
      repeatHeader.innerText = "Repeat";
      repeatHeader.style.width = "100%";

      let repeat = document.createElement("div");
      repeat.id = "repeat";
      repeat.classList.add("enemy");
      let repeatNum = document.createElement("div");
      repeatNum.classList.add("repeatNumber");
      repeatNum.innerText = "2×";
      repeat.append(repeatNum);
      repeat.draggable = true;
      repeat.ondragstart = () => draggingEnemy = {
        code: "repeat",
        el: repeat.cloneNode()
      };
      repeat.ondragend = () => draggingEnemy = null;

      let wavesText;
      if (!document.getElementById("wavesText")) {
        wavesText = document.createElement("textarea");
        wavesText.id = "wavesText";
        wavesText.spellcheck = false;
        wavesText.classList.add("light", "hidden");
      }

      let instructions = document.createElement("div");
      instructions.id = "wavesInstructions";
      instructions.classList.add("vCentered", "hidden");
      instructions.innerHTML = `
        <h3>Enemy codes:</h3>
        <div id="enemyCodes">
          Types (first charcter):
          <ul>
            <li>"<span class="mono">g</span>" — green
            <li>"<span class="mono">y</span>" — yellow
            <li>"<span class="mono">o</span>" — orange
            <li>"<span class="mono">r</span>" — red
            <li>"<span class="mono">p</span>" — purple
            <li>"<span class="mono">b</span>" — brown
            <li>"<span class="mono">x</span>" — boss
            <li>"<span class="mono">z</span>" — brown-boss
            <li>"<span class="mono">u</span>" — purple-boss
          </ul>
          Abilities (second character):
          <ul>
            <li>"<span class="mono">h</span>" — healing
            <li>"<span class="mono">a</span>" — acceleration
            <li>"<span class="mono">s</span>" — split
            <li>"<span class="mono">k</span>" — blink
            <li>"<span class="mono">d</span>" — shield
          </ul>
        </div>
        <div><b>Note: green, brown-boss, and purple-boss enemies can't have the split ability.</b></div>
        <br>
        <h3>Other:</h3>
        <div>
          Pause: <span class="mono">pause</span><br>
          Alert: <span class="mono">["alert", message]</span><br>
          Repeat: <span class="mono">[number, contents]</span>
        </div>
        <br>
        <h3>Example wave:</h3>
        <b class="mono">["pa", "bh", pause, [5, "o", [3, "y"]]]</b>
      `;

      let nextButton = document.getElementById("next");
      nextButton.style.left = "62%";
      nextButton.onclick = finishMap;

      let exitButton = document.createElement("button");
      exitButton.id = "exit";
      exitButton.innerText = "Save & exit";
      exitButton.onclick = exitEditor;

      let testButton = document.createElement("button");
      testButton.id = "test";
      testButton.innerText = "Test map";
      testButton.onclick = testMap;

      enemiesBox.append(pauseHeader, alertHeader, pauseWrapper, alertWrapper, repeatHeader, repeat)
      document.getElementById("lightBackground").append(enemiesBox, instructions, exitButton, testButton);
      if (wavesBox) document.getElementById("lightBackground").append(wavesBox, wavesText);
      
      if (editingMap) {
        if (JSON.stringify(newWavesArr) == JSON.stringify(wavesDefault)) newWavesArr = Array(75).fill().map(() => []);
        newWavesArr = JSON.parse(JSON.stringify(newWavesArr).replaceAll("[10,null]", "\"pause\""));
        updateWavesText();
        validateWavesText();
        fillWaves();
      }
    }

    function addEnemy(enemy, ability, wave, position) {
      if (!enemy) return;

      let container = document.getElementById("container");

      if (!Object.values(enemyTypes).includes(enemy)) ability = null; //Pause and Alert can't have abilities
      
      document.getElementById("enemyOutline")?.remove();
      let wrapper = document.createElement("div");
      wrapper.classList.add("waveEnemy");
      if (enemy.boss) wrapper.classList.add("boss");
      wrapper.ondrag = function() {
        this.remove();
      }
      wrapper.ondragstart = () => { //Pick up item
        draggingEnemy = enemy;
        draggingAbility = ability;
        position = getUpdatedPosition(wrapper); //Reset the item's position in case anything has been moved.
        newWavesArr[wave].splice(position, 1);
        document.getElementById("removeItem").classList.remove("hidden");
      };
      wrapper.ondragend = () => {
        draggingEnemy = null;
        draggingAbility = document.getElementById("abilityDropdown").value;
        document.getElementById("removeItem").classList.add("hidden");
      };

      if (enemy.code == "repeat") {
        enemy.arr ??= [2];
        wrapper.classList.add("waveRepeat");
        let repeatNum = document.createElement("div");
        repeatNum.classList.add("repeatNumber");
        let rnInput = document.createElement("input");
        rnInput.type = "number";
        rnInput.classList.add("line");
        rnInput.value = enemy.arr[0];
        rnInput.min = 2;
        rnInput.max = 999;
        rnInput.onfocus = function() {
          this.select();
        };
        rnInput.onchange = function() {
          if (this.value < 2) this.value = 2;
          if (this.value > 999) this.value = 999;
          if (!Number.isInteger(this.value)) this.value = Math.floor(this.value);
          this.value = +this.value;
          enemy.arr[0] = +this.value;
        };
        //Don't drag the parent when selecting in the input
        rnInput.draggable = true;
        rnInput.ondragstart = function() {
          event.preventDefault();
          event.stopPropagation();
        };
        repeatNum.append(rnInput, "×");
        wrapper.append(repeatNum);
        wrapper.draggable = true;
        wrapper.ondragenter = function() {
          if (draggingEnemy.code == "alert") return; //No alerts in repeat arrays
          let outline = document.createElement("div");
          outline.id = "repeatEnemyOutline";
          outline.classList.add("waveEnemy");
          if (draggingEnemy.boss) outline.classList.add("boss");
          if (draggingEnemy.code == "repeat") outline.classList.add("waveRepeat");
          this.append(outline);
          event.stopPropagation();
        };
        wrapper.ondragover = function() {
          if (draggingEnemy.code == "alert") return;
          event.preventDefault();
          this.classList.add("dragTarget");
          if (!document.getElementById("repeatEnemyOutline")) this.ondragenter(); //Outline sometimes fails to appear on dragenter
          draggingPosition = this.children.length - 1;
          let repeatNumLine = this.children[0].getBoundingClientRect().x + this.children[0].getBoundingClientRect().width;
          if (event.clientX < repeatNumLine) { //Dragging over repeatNumber
            Array.from(this.children).forEach(child => child.style.order = 0); //Move the item being dragged to the end
          } else {
            Array.from(this.children).forEach((child, i) => {
              let xCenter = child.getBoundingClientRect().x + child.getBoundingClientRect().width / 2;
              child.style.order = (event.clientX < xCenter && !child.id && !child.classList.contains("repeatNumber")) ? 1 : 0; //Excluding elements with ids so the order of #enemyOutline is always 0
              if (event.clientX > xCenter && !child.id) draggingPosition = i; //Make draggingPosition equal to the number of wave items to the left of #enemyOutline
            });
          }
          event.stopPropagation();
        };
        wrapper.ondragleave = function() {
          this.classList.remove("dragTarget");
          document.getElementById("repeatEnemyOutline")?.remove();
          Array.from(this.children).forEach(child => child.style.order = 0); //Reset order of elements
        };
        wrapper.ondrop = function() {
          if (draggingEnemy.code == "alert") return;
          this.classList.remove("dragTarget");
          position = getUpdatedPosition(wrapper);
          addToRepeat(draggingEnemy, draggingAbility, wave, position, null, draggingPosition, this);
          document.getElementById("repeatEnemyOutline").remove();
          Array.from(this.children).forEach(child => child.style.order = 0); //Reset order of elements
          event.stopPropagation();
        };
        wrapper.oncontextmenu = function() {
          event.preventDefault();
          event.stopPropagation();
          document.getElementById("contextMenu")?.remove();
          let menu = document.createElement("div");
          menu.id = "contextMenu";
          menu.style.left = event.clientX - container.getBoundingClientRect().x + "px";
          menu.style.top = event.clientY - container.getBoundingClientRect().y + "px";
          let header = document.createElement("b");
          header.innerText = "Repeat";
          let itemsOut = document.createElement("div");
          itemsOut.innerText = "Take items out";
          if (enemy.arr.length < 2) itemsOut.classList.add("unselectable");
          itemsOut.onmousedown = () => event.stopPropagation();
          itemsOut.onclick = () => {
            if (enemy.arr.length < 2) return;
            this.ondragstart();
            this.ondrag();
            this.ondragend();
            let repeatItems = enemy.arr.slice(1);
            repeatItems.forEach((item, i) => {
              if (item == "pause") addEnemy({code: "pause", img: pauseImg}, null, wave, position + i);
              else if (Array.isArray(item)) addEnemy({code: "repeat", arr: item}, null, wave, position + i);
              else for (let type in enemyTypes) if (item[0] == enemyTypes[type].code) addEnemy(enemyTypes[type], item[1], wave, position + i);
            });
            menu.remove();
          };
          let duplicate = document.createElement("div");
          duplicate.innerText = "Duplicate";
          duplicate.onmousedown = () => event.stopPropagation();
          duplicate.onclick = () => {
            position = getUpdatedPosition(wrapper);
            let newEnemy = JSON.parse(JSON.stringify(enemy));
            addEnemy(newEnemy, ability, wave, position);
            menu.remove();
          };
          let remove = document.createElement("div");
          remove.innerText = "Remove";
          remove.onmousedown = () => event.stopPropagation();
          remove.onclick = () => {
            this.ondragstart();
            this.ondrag();
            this.ondragend();
            menu.remove();
          };
          menu.append(header, itemsOut, duplicate, remove);
          container.append(menu);
        };
      } else {
        if (ability == "k") wrapper.classList.add("blink");
        let img = new Image();
        img.src = (ability == "s") ? (enemy.imgSplitRotated?.src || enemy.imgSplit.src) : (enemy.imgRotated?.src || enemy.img.src);
        let abilitySymbol = new Image();
        switch (ability) {
          case "h":
            abilitySymbol.src = images.abilitySymbols.healing.src;
            break;
          case "a":
            abilitySymbol.src = images.abilitySymbols.acceleration.src;
            break;
          case "d":
            abilitySymbol.src = images.abilitySymbols.shield.src;
        }
        abilitySymbol.classList.add("abilitySymbol", "centered");
        wrapper.append(img, abilitySymbol);
        wrapper.oncontextmenu = function() {
          event.preventDefault();
          event.stopPropagation();
          document.getElementById("contextMenu")?.remove();
          let menu = document.createElement("div");
          menu.id = "contextMenu";
          menu.style.left = event.clientX - container.getBoundingClientRect().x + "px";
          menu.style.top = event.clientY - container.getBoundingClientRect().y + "px";
          let header = document.createElement("b");
          let abilityName;
          if (!ability) abilityName = "Normal";
          if (ability == "h") abilityName = "Healing";
          if (ability == "a") abilityName = "Acceleration";
          if (ability == "s") abilityName = "Split";
          if (ability == "k") abilityName = "Blink";
          if (ability == "d") abilityName = "Shield";
          if (enemy.code == "pause") header.innerText = "Pause";
          else if (enemy.code == "alert") header.innerText = "Alert";
          else header.innerText = `${enemy.name}, ${abilityName}`;
          let editAlert = "";
          if (enemy.code == "alert") {
            editAlert = document.createElement("div");
            editAlert.innerText = "Edit alert";
            editAlert.onmousedown = () => event.stopPropagation();
            editAlert.onclick = () => {
              wrapper.click();
              menu.remove();
            };
          }
          let duplicate = document.createElement("div");
          duplicate.innerText = "Duplicate";
          duplicate.onmousedown = () => event.stopPropagation();
          duplicate.onclick = () => {
            position = getUpdatedPosition(wrapper);
            let newEnemy = (enemy.code == "alert") ? JSON.parse(JSON.stringify(enemy)) : enemy; //Create a new array for duplicated alerts so they can have different messages
            newEnemy.img = enemy.img; //Converting to JSON removes the image
            addEnemy(newEnemy, ability, wave, position);
            menu.remove();
          };
          let remove = document.createElement("div");
          remove.innerText = "Remove";
          remove.onmousedown = () => event.stopPropagation();
          remove.onclick = () => {
            this.ondragstart();
            this.ondrag();
            this.ondragend();
            menu.remove();
          };
          menu.append(header, editAlert, duplicate, remove);
          container.append(menu);
        };
      }
      let waveEl = document.getElementById("wave" + wave);
      waveEl.insertBefore(wrapper, waveEl.children[position + 1]);
      if (ability == "k") wrapper.getAnimations()[0].startTime = 0; //Sync blinking animations

      if (enemy.code == "alert") {
        if (enemy.arr) {
          newWavesArr[wave].splice(position, 0, enemy.arr);
        } else {
          gameAlert("Alert text:", "prompt", "normal", null);
          document.getElementById("ok").classList.add("unselectable");
          document.getElementById("alertInput").oninput = function() {
            if (this.value.trim()) document.getElementById("ok").classList.remove("unselectable");
            else document.getElementById("ok").classList.add("unselectable");
          };
          document.getElementById("ok").onclick = () => {
            if (!document.getElementById("alertInput").value.trim()) return;
            enemy.arr = ["alert", document.getElementById("alertInput").value];
            //If there are an odd number of backslashes at the end of the message, add another to prevent errors
            let reversed = enemy.arr[1].split("").reverse();
            let backslashesAtEnd = reversed.indexOf(reversed.find(char => char != "\\"));
            if (backslashesAtEnd == -1) backslashesAtEnd = enemy.arr[1].length;
            if (backslashesAtEnd % 2) enemy.arr[1] += "\\";
            newWavesArr[wave].splice(position, 0, enemy.arr);
            resumeGame(); //Hide the alert
          }
        }
        wrapper.title = "Edit alert";
        wrapper.onclick = () => {
          gameAlert("Alert text:", "prompt", "normal", null, enemy.arr[1]);
          document.getElementById("alertInput").oninput = function() {
            if (this.value.trim()) document.getElementById("ok").classList.remove("unselectable");
            else document.getElementById("ok").classList.add("unselectable");
          };
          document.getElementById("ok").onclick = () => {
            if (!document.getElementById("alertInput").value.trim()) return;
            enemy.arr[1] = document.getElementById("alertInput").value;
            //If there are an odd number of backslashes at the end of the message, add another to prevent errors
            let reversed = enemy.arr[1].split("").reverse();
            let backslashesAtEnd = reversed.indexOf(reversed.find(char => char != "\\"));
            if (backslashesAtEnd == -1) backslashesAtEnd = enemy.arr[1].length;
            if (backslashesAtEnd % 2) enemy.arr[1] += "\\";
            resumeGame(); //Hide the alert
          }
        };
      } else {
        newWavesArr[wave].splice(position, 0, enemy.arr || enemy.code + (ability || ""));
      }

      if (enemy.code == "repeat") {
        let repeatItems = enemy.arr.slice(1);
        enemy.arr.length = 1; //Clear the array except for the number at the start
        //Display the contents of the repeat array
        repeatItems.forEach((item, i) => {
          if (item == "pause") addToRepeat({code: "pause", img: pauseImg}, null, wave, position, null, i, wrapper);
          else if (Array.isArray(item)) addToRepeat({code: "repeat", arr: item}, null, wave, position, null, i, wrapper);
          else for (let type in enemyTypes) if (item[0] == enemyTypes[type].code) addToRepeat(enemyTypes[type], item[1], wave, position, null, i, wrapper);
        });
      }
    }

    function addToRepeat(enemy, ability, wave, outerIndex, innerIndex, position, el) {
      if (!enemy) return;

      let container = document.getElementById("container");

      if (!Object.values(enemyTypes).includes(enemy)) ability = null; //Pause and Alert can't have abilities
      
      let wrapper = document.createElement("div");
      wrapper.classList.add("waveEnemy");
      if (enemy.boss) wrapper.classList.add("boss");
      wrapper.ondrag = function() {
        this.remove();
        event.stopPropagation();
      }
      wrapper.ondragstart = () => { //Pick up item
        draggingEnemy = enemy;
        draggingAbility = ability;
        position = getUpdatedPosition(wrapper);
        if (innerIndex == null) newWavesArr[wave][outerIndex].splice(position + 1, 1);
        else newWavesArr[wave][outerIndex][innerIndex + 1].splice(position + 1, 1);
        document.getElementById("removeItem").classList.remove("hidden");
        event.stopPropagation();
      };
      wrapper.ondragend = () => {
        draggingEnemy = null;
        draggingAbility = document.getElementById("abilityDropdown").value;
        document.getElementById("removeItem").classList.add("hidden");
      };

      if (enemy.code == "repeat") {
        enemy.arr ??= [2];
        wrapper.classList.add("waveRepeat");
        let repeatNum = document.createElement("div");
        repeatNum.classList.add("repeatNumber");
        let rnInput = document.createElement("input");
        rnInput.type = "number";
        rnInput.classList.add("line");
        rnInput.value = enemy.arr[0];
        rnInput.min = 2;
        rnInput.max = 999;
        rnInput.onclick = function() {
          this.select();
        };
        rnInput.onchange = function() {
          if (this.value < 2) this.value = 2;
          if (this.value > 999) this.value = 999;
          if (!Number.isInteger(this.value)) this.value = Math.floor(this.value);
          this.value = +this.value;
          enemy.arr[0] = +this.value;
        };
        //Don't drag the parent when selecting in the input
        rnInput.draggable = true;
        rnInput.ondragstart = function() {
          event.preventDefault();
          event.stopPropagation();
        };
        repeatNum.append(rnInput, "×");
        wrapper.append(repeatNum);
        wrapper.draggable = true;
        wrapper.ondragenter = function() {
          if (draggingEnemy.code == "alert" || draggingEnemy.code == "repeat") return; //No alerts or further nested repeat arrays
          let outline = document.createElement("div");
          outline.id = "innerRepeatEnemyOutline";
          outline.classList.add("waveEnemy");
          if (draggingEnemy.boss) outline.classList.add("boss");
          if (draggingEnemy.code == "repeat") outline.classList.add("waveRepeat");
          this.append(outline);
          event.stopPropagation();
        };
        wrapper.ondragover = function() {
          if (draggingEnemy.code == "alert" || draggingEnemy.code == "repeat") return;
          event.preventDefault();
          this.classList.add("dragTarget");
          draggingPosition = this.children.length - 1;
          let repeatNumLine = this.children[0].getBoundingClientRect().x + this.children[0].getBoundingClientRect().width;
          if (event.clientX < repeatNumLine) { //Dragging over repeatNumber
            Array.from(this.children).forEach(child => child.style.order = 0); //Move the item being dragged to the end
          } else {
            Array.from(this.children).forEach((child, i) => {
              let xCenter = child.getBoundingClientRect().x + child.getBoundingClientRect().width / 2;
              child.style.order = (event.clientX < xCenter && !child.id && !child.classList.contains("repeatNumber")) ? 1 : 0; //Excluding elements with ids so the order of #enemyOutline is always 0
              if (event.clientX > xCenter && !child.id) draggingPosition = i; //Make draggingPosition equal to the number of wave items to the left of #enemyOutline
            });
          }
          event.stopPropagation();
        };
        wrapper.ondragleave = function() {
          this.classList.remove("dragTarget");
          document.getElementById("innerRepeatEnemyOutline")?.remove();
          Array.from(this.children).forEach(child => child.style.order = 0); //Reset order of elements
        };
        wrapper.ondrop = function() {
          if (draggingEnemy.code == "alert" || draggingEnemy.code == "repeat") return;
          this.classList.remove("dragTarget");
          position = getUpdatedPosition(wrapper);
          addToRepeat(draggingEnemy, draggingAbility, wave, outerIndex, position, draggingPosition, this);
          document.getElementById("innerRepeatEnemyOutline").remove();
          Array.from(this.children).forEach(child => child.style.order = 0); //Reset order of elements
          event.stopPropagation();
        };
        wrapper.oncontextmenu = function() {
          event.preventDefault();
          event.stopPropagation();
          document.getElementById("contextMenu")?.remove();
          let menu = document.createElement("div");
          menu.id = "contextMenu";
          menu.style.left = event.clientX - container.getBoundingClientRect().x + "px";
          menu.style.top = event.clientY - container.getBoundingClientRect().y + "px";
          let header = document.createElement("b");
          header.innerText = "Repeat";
          let itemsOut = document.createElement("div");
          itemsOut.innerText = "Take items out";
          if (enemy.arr.length < 2) itemsOut.classList.add("unselectable");
          itemsOut.onmousedown = () => event.stopPropagation();
          itemsOut.onclick = () => {
            if (enemy.arr.length < 2) return;
            this.ondragstart();
            this.ondrag();
            this.ondragend();
            let repeatItems = enemy.arr.slice(1);
            repeatItems.forEach((item, i) => {
              if (item == "pause") addToRepeat({code: "pause", img: pauseImg}, null, wave, outerIndex, null, i + position, el);
              else for (let type in enemyTypes) if (item[0] == enemyTypes[type].code) addToRepeat(enemyTypes[type], item[1], wave, outerIndex, null, i + position, el);
            });
            menu.remove();
          };
          let duplicate = document.createElement("div");
          duplicate.innerText = "Duplicate";
          duplicate.onmousedown = () => event.stopPropagation();
          duplicate.onclick = () => {
            position = getUpdatedPosition(wrapper);
            addToRepeat(enemy, ability, wave, outerIndex, innerIndex, position, el);
            menu.remove();
          };
          let remove = document.createElement("div");
          remove.innerText = "Remove";
          remove.onmousedown = () => event.stopPropagation();
          remove.onclick = () => {
            this.ondragstart();
            this.ondrag();
            this.ondragend();
            menu.remove();
          };
          menu.append(header, itemsOut, duplicate, remove);
          container.append(menu);
        };
      } else {
        if (ability == "k") wrapper.classList.add("blink");
        let img = new Image();
        img.src = (ability == "s") ? (enemy.imgSplitRotated?.src || enemy.imgSplit.src) : (enemy.imgRotated?.src || enemy.img.src);
        let abilitySymbol = new Image();
        switch (ability) {
          case "h":
            abilitySymbol.src = images.abilitySymbols.healing.src;
            break;
          case "a":
            abilitySymbol.src = images.abilitySymbols.acceleration.src;
            break;
          case "d":
            abilitySymbol.src = images.abilitySymbols.shield.src;
        }
        abilitySymbol.classList.add("abilitySymbol", "centered");
        wrapper.append(img, abilitySymbol);
        wrapper.oncontextmenu = function() {
          event.preventDefault();
          event.stopPropagation();
          document.getElementById("contextMenu")?.remove();
          let menu = document.createElement("div");
          menu.id = "contextMenu";
          menu.style.left = event.clientX - container.getBoundingClientRect().x + "px";
          menu.style.top = event.clientY - container.getBoundingClientRect().y + "px";
          let header = document.createElement("b");
          let abilityName;
          if (!ability) abilityName = "Normal";
          if (ability == "h") abilityName = "Healing";
          if (ability == "a") abilityName = "Acceleration";
          if (ability == "s") abilityName = "Split";
          if (ability == "k") abilityName = "Blink";
          if (ability == "d") abilityName = "Shield";
          if (enemy.code == "pause") header.innerText = "Pause";
          else if (enemy.code == "alert") header.innerText = "Alert";
          else header.innerText = `${enemy.name}, ${abilityName}`;
          let duplicate = document.createElement("div");
          duplicate.innerText = "Duplicate";
          duplicate.onmousedown = () => event.stopPropagation();
          duplicate.onclick = () => {
            position = getUpdatedPosition(wrapper);
            addToRepeat(enemy, ability, wave, outerIndex, innerIndex, position, el);
            menu.remove();
          };
          let remove = document.createElement("div");
          remove.innerText = "Remove";
          remove.onmousedown = () => event.stopPropagation();
          remove.onclick = () => {
            this.ondragstart();
            this.ondrag();
            this.ondragend();
            menu.remove();
          };
          menu.append(header, duplicate, remove);
          container.append(menu);
        };
      }
      el.insertBefore(wrapper, el.children[position + 1]);
      if (ability == "k") wrapper.getAnimations()[0].startTime = 0; //Sync blinking animations

      if (innerIndex == null) newWavesArr[wave][outerIndex].splice(position + 1, 0, enemy.arr || enemy.code + (ability || ""));
      else newWavesArr[wave][outerIndex][innerIndex + 1].splice(position + 1, 0, enemy.arr || enemy.code + (ability || ""));

      if (enemy.code == "repeat") {
        let repeatItems = enemy.arr.slice(1);
        enemy.arr.length = 1; //Clear the array except for the number at the start
        //Display the contents of the repeat array
        repeatItems.forEach((item, i) => {
          if (item == "pause") addToRepeat({code: "pause", img: pauseImg}, null, wave, outerIndex, position, i, wrapper);
          else if (Array.isArray(item)) addToRepeat({code: "repeat", arr: item}, null, wave, outerIndex, position, i, wrapper);
          else for (let type in enemyTypes) if (item[0] == enemyTypes[type].code) addToRepeat(enemyTypes[type], item[1], wave, outerIndex, position, i, wrapper);
        });
      }
    }

    function getUpdatedPosition(el) {
      return Array.from(el.parentElement.children).indexOf(el) - 1; //Subtract 1 because the waveNumber/repeatNumber is the first child
    }

    function updateWavesText() {
      let newWavesStr = "";
      newWavesArr.forEach((wave, i) => {
        if (i == 50) newWavesStr += "\n"; //Add a line break before the hard-mode-only waves
        newWavesStr += "[";
        wave.forEach((item, j) => {
          if (item == "pause") {
            newWavesStr += item;
          } else if (item[0] == "alert") {
            let alertCharacters = item[1].split("");
            //Escape double quotes that aren't already escaped
            alertCharacters.forEach((char, i) => {
              if (char == "\"") {
                let charactersBefore = alertCharacters.slice(0, i).reverse();
                let backslashesBefore = charactersBefore.indexOf(charactersBefore.find(char => char != "\\"));
                if (backslashesBefore == -1) backslashesBefore = charactersBefore.length;
                if (!(backslashesBefore % 2)) alertCharacters[i] = "\\\"";
              }
            });
            newWavesStr += `["alert", "${alertCharacters.join("")}"]`;
          } else if (Array.isArray(item)) {
            newWavesStr += "[";
            item.forEach((subitem, k) => {
              if (subitem == "pause") newWavesStr += subitem;
              else if (typeof subitem == "string") newWavesStr += `"${subitem}"`;
              else if (Array.isArray(subitem)) newWavesStr += `[${subitem.map(subsubitem => (typeof subsubitem == "string" && subsubitem != "pause") ? `"${subsubitem}"` : subsubitem).join(", ")}]`;
              else newWavesStr += subitem;
              if (k < item.length - 1) newWavesStr += ", ";
            });
            newWavesStr += "]";
          } else {
            newWavesStr += `"${item}"`;
          }
          if (j < wave.length - 1) newWavesStr += ", ";
        });
        newWavesStr += "]";
        if (i < newWavesArr.length - 1) newWavesStr += ",\n";
      });
      document.getElementById("wavesText").value = newWavesStr;
    }

    function validateWavesText() {
      let str = document.getElementById("wavesText").value;
      let lastQuoteMark;
      let quoteMarkCounter = 0;
      let findItemEnd;
      let strCharacters = str.split("");
      //Convert single quotes to double quotes without affecting apostrophes or quotation marks in alerts
      strCharacters.forEach((char, i) => {
        if (char == "\"" || char == "'") {
          lastQuoteMark ||= char;
          //Get the number of backslashes before this character
          let charactersBefore = strCharacters.slice(0, i).reverse();
          let backslashesBefore = charactersBefore.indexOf(charactersBefore.find(char => char != "\\"));
          if (char != lastQuoteMark && !(backslashesBefore % 2) && quoteMarkCounter % 2) { //Single quote inside double quotes or vice versa
            if (char == "\"") strCharacters[i] = "\\\""; //Add a backslash to escape double quotes
          } else if (!(backslashesBefore % 2)) {
            lastQuoteMark = char;
            strCharacters[i] = "\""; //Replace single quotes with double quotes
            quoteMarkCounter++;
          }
        } else if (!(quoteMarkCounter % 2)) { //char is not inside quotes
          //Add missing quotes around items
          if (/[a-z]/.test(char)) {
            if (!findItemEnd) {
              strCharacters[i] = "\"" + char;
              findItemEnd = true; //Add closing quotation marks after the next character that is not a letter
            }
          } else if (findItemEnd) {
            strCharacters[i] = "\"" + char;
            findItemEnd = false;
          }
        }
      });
      //Double backslashes unless they are escaping quotes
      strCharacters.forEach((char, i) => {
        if (char == "\\") {
          let charactersBefore = strCharacters.slice(0, i).reverse();
          let backslashesBefore = charactersBefore.indexOf(charactersBefore.find(char => char != "\\\\"));
          if (strCharacters[i + 1] != "\"" || backslashesBefore % 2) strCharacters[i] = "\\\\";
        }
      });
      str = strCharacters.join("").trim();
      if (str.at(-1) == ",") str = str.slice(0, -1);
      let newWavesJSON = "[" + str + "]";
      try {
        wavesFromText = JSON.parse(newWavesJSON);
      } catch {
        return;
      }

      for (let i = wavesFromText.length; i < 75; i++) wavesFromText.push([]); //Add empty arrays if there are less than 75 waves

      try {
        let testingArr = JSON.parse(JSON.stringify(wavesFromText));
        let testingWave = 0;
        let testingEnemy = 0;

        while (testingWave < 75) {
          let next = testingArr[testingWave][testingEnemy];
          if (next == "pause") next = [10, null];
          while (Array.isArray(next)) {
            if (next[0] == "alert") {
              if (!next[1]) return; //No alert text
              testingArr[testingWave].splice(testingEnemy, 1); //Remove the array
            } else {
              if (!Number.isInteger(next[0])) return; //First item in the array is not a number
              let repeat = next[0]; //The array's first item is the number of times to repeat
              let items = next.slice(1); //Everything that follows is repeated
              let repeated = Array(repeat).fill(items).flat(); //Make an array containing the items array repeated, then flatten it
              testingArr[testingWave].splice(testingEnemy, 1, ...repeated); //Add each item in repeated to the wave and remove the array
            }
            next = testingArr[testingWave][testingEnemy];
            if (next == "pause") next = [10, null];
          }
          if (next) {
            if (next.length > 2) return; //Too many characters
            if (["gs", "zs", "us"].includes(next)) return; //Green, brown-boss, and purple-boss enemies can't have the split ability
            let enemyObject = new Enemy(next);
            if (next.length == 2 && !enemyObject.abilities.length) return; //Invalid second character
          }
          
          if (testingArr[testingWave][testingEnemy + 1] !== undefined) { //If there are enemies left in the wave
            testingEnemy++;
          } else {
            testingWave++;
            testingEnemy = 0;
          }
        }
      } catch {
        return;
      }
      return wavesFromText.every(wave => Array.isArray(wave));
    }

    function wftError() {
      if (wavesFromText.length > 75) return "too many waves.";
      if (wavesFromText.some(wave => wave.some(item => item[0] < 2))) return "repeat numbers can't be under 2.";
      if (wavesFromText.some(wave => wave.some(item => item[0] > 999))) return "repeat numbers can't be over 999.";
      if (wavesFromText.some(wave => wave.some(item => Array.isArray(item) && item.some(subitem => subitem[0] == "alert" || Array.isArray(subitem) && subitem.some(subsubitem => subsubitem[0] == "alert"))))) return "alerts can't go inside repeat arrays.";
      if (wavesFromText.some(wave => wave.some(item => Array.isArray(item) && item.some(subitem => Array.isArray(subitem) && subitem.some(subsubitem => Array.isArray(subsubitem)))))) return "you can't have more than three levels of nested arrays.";
    }

    function clearWaves() {
      newWavesArr.forEach((wave, i) => {
        newWavesArr[i] = [];
        let waveEl = document.getElementById("wave" + i);
        let waveEnemies = Array.from(waveEl.children).slice(1);
        waveEnemies.forEach(enemy => enemy.remove());
      });
    }

    function fillWaves() {
      clearWaves();
      wavesFromText.forEach((wave, i) => wave.forEach((item, j) => {
        if (item == "pause") addEnemy({code: "pause", img: pauseImg}, null, i, j);
        else if (item[0] == "alert") addEnemy({code: "alert", img: alertImg, arr: item}, null, i, j);
        else if (Array.isArray(item)) addEnemy({code: "repeat", arr: item}, null, i, j);
        else for (let type in enemyTypes) if (item[0] == enemyTypes[type].code) addEnemy(enemyTypes[type], item[1], i, j);
      }));
    }

    function checkForChanges() {
      let oldMap = editingMap || {start: undefined, lines: [], waves: wavesDefault};
      if (JSON.stringify([newPathStart[1] - 0.5, newPathStart[0] - 0.5]) != JSON.stringify(oldMap.start)) return true;
      if (JSON.stringify(newPathArr) != JSON.stringify(oldMap.lines)) return true;
      if (newWavesArr.every(wave => !wave.length) && JSON.stringify(oldMap.waves) == JSON.stringify(wavesDefault)) return;
      if (JSON.stringify(newWavesArr).replaceAll("\"pause\"", "[10,null]") != JSON.stringify(oldMap.waves)) return true;
    }

    function createMapObject() {
      return {
        name: newMapName,
        author: "{{ username }}",
        digipogs: newMapDP,
        id: editingMap?.id || Date.now(),
        start: [newPathStart[1] - 0.5, newPathStart[0] - 0.5],
        lines: newPathArr,
        waves: JSON.parse(JSON.stringify(newWavesArr).replaceAll("\"pause\"", "[10,null]")),
        edited: Date.now()
      };
    }

    function exitEditor() {
      //Check if the text input is valid, and update the waves array if so
      if (document.getElementById("text")?.classList.contains("pressed")) {
        if (!validateWavesText()) return gameAlert("Can't convert your text to waves. Check for errors.");
        let errorAlert = wftError();
        if (errorAlert) return gameAlert("Error: " + errorAlert);
        fillWaves();
      }

      newMap = createMapObject();
      newMap.status = (editingMap?.status == "ready" && !checkForChanges()) ? "ready" : "uncleared";
      if (editingMap) {
        if (checkForChanges()) {
          request.open("POST", "/edittdmap?id=" + newMap.id + "&map=" + JSON.stringify(newMap));
          request.send();
        }
      } else {
        request.open("POST", "/createtdmap?map=" + JSON.stringify(newMap));
        request.send();
      }
      window.onbeforeunload = null;
      window.location.reload();
    }

    function testMap() {
      //Check if the text input is valid, and update the waves array if so
      if (document.getElementById("text")?.classList.contains("pressed")) {
        if (!validateWavesText()) return gameAlert("Can't convert your text to waves. Check for errors.");
        let errorAlert = wftError();
        if (errorAlert) return gameAlert("Error: " + errorAlert);
        fillWaves();
      }
      
      testing = true;
      map = createMapObject();
      startGame();
    }

    function finishMap() {
      //Check if the text input is valid, and update the waves array if so
      if (document.getElementById("text")?.classList.contains("pressed")) {
        if (!validateWavesText()) return gameAlert("Can't convert your text to waves. Check for errors.");
        let errorAlert = wftError();
        if (errorAlert) return gameAlert("Error: " + errorAlert);
        fillWaves();
      }
      
      if (newWavesArr.some(wave => !wave.length || wave.filter(item => item[0] != "alert").flat(2).every(item => item == "pause" || typeof item == "number"))) {
        return gameAlert("Error: each wave must contain at least one enemy.");
      }

      if (newWavesArr.some(wave => wave.some(item => Array.isArray(item) && (item.length == 1 || item.some(subitem => Array.isArray(subitem) && subitem.length == 1))))) {
        return gameAlert("Error: some repeat boxes are empty.");
      }

      if (newWavesArr.every(wave => !wave.length)) newWavesArr = wavesDefault;

      let newMap = createMapObject();
      if (editingMap?.status == "ready" && !checkForChanges()) {
        editingMap.status = "published";
        request.open("POST", "/tdmapstatus?id=" + editingMap.id + "&status=published");
        request.send();
        gameAlert("Map published.");
        if (document.getElementById("myMaps")) {
          let statusBox = document.getElementById("status" + editingMap.id);
          statusBox.classList.remove("ready");
          statusBox.classList.add("published");
          statusBox.innerText = "published";
        }
        if (document.getElementById("lightBackground")) document.getElementById("ok").onclick = () => window.location.reload();
      } else {
        gameAlert("Before you can publish your map, you need to complete it on hard mode. Do you want to try now?", "confirm", "normal", () => {
          testing = false;
          clearCheck = true;
          difficulty = "hard";
          if (editingMap) {
            if (checkForChanges()) {
              newMap.status = "uncleared";
              request.open("POST", "/edittdmap?id=" + newMap.id + "&map=" + JSON.stringify(newMap));
              request.send();
            }
          } else {
            newMap.status = "uncleared";
            request.open("POST", "/createtdmap?map=" + JSON.stringify(newMap));
            request.send();
          }
          map = newMap;
          startGame();
        });
        if (document.getElementById("lightBackground")) document.getElementById("no").onclick = exitEditor;
      }
    }
  }
</script>
{% endblock %}